#Power Of A Number
"""
Write a program to find x to the power n (i.e. x^n). Take x and n from the user. You need to print the answer.
Note : For this question, you can assume that 0 raised to the power of 0 is 1

Input format :
Two integers x and n (separated by space)

Output Format :
x^n (i.e. x raise to the power n)
"""
Sample Input 1 :
 3 4
Sample Output 1 :
81

Sample Input 2 :
 2 5
Sample Output 2 :
32

Solution :

def Power_Number(X,N):
    output=X**N
    return output

str=input().split()
x,n=int(str[0]),int(str[1])
r=Power_Number(x,n)
print(r)


#Sum Of Array
"""
Given an array of length N, you need to find and return the sum of all elements of the array.
Do this recursively.

Input Format :
Line 1 : An Integer N i.e. size of array
Line 2 : N integers which are elements of the array, separated by spaces

Output Format :
Sum
"""
Sample Input 1 :
3
9 8 9
Sample Output 1 :
26

Sample Input 2 :
3
4 2 1
Sample Output 2 :
7

Solution :

n=int(input())
li=[int(x) for x in input().split()]
sum = 0
for list_ele in li:
    sum=sum+list_ele
print(sum)


#Check Number in Array
"""
Given an array of length N and an integer x, you need to find if x is present in the array or not. Return true or false.
Do this recursively.

Input Format :
Line 1 : An Integer N i.e. size of array
Line 2 : N integers which are elements of the array, separated by spaces
Line 3 : Integer x

Output Format :
'true' or 'false'
"""
Sample Input 1 :
3
9 8 10
8
Sample Output 1 :
true

Sample Input 2 :
3
9 8 10
2
Sample Output 2 :
false

Solution :

def NumberinArray(li):
    if x in li:
        print("true")
    else:
        print("false")

from sys import setrecursionlimit

setrecursionlimit(11000)
n = int(input())
li = [int(x) for x in input().split()]
x = int(input())
NumberinArray(li)


#First Index of Number - Question
"""
Given an array of length N and an integer x, you need to find and return the first index of integer x present in the array. Return -1 if it is not present in the array.
First index means, the index of first occurrence of x in the input array.
Do this recursively. Indexing in the array starts from 0.

Input Format :
Line 1 : An Integer N i.e. size of array
Line 2 : N integers which are elements of the array, separated by spaces
Line 3 : Integer x

Output Format :
first index or -1
"""
Sample Input :
4
9 8 10 8
8
Sample Output :
1

Solution :

def FirstIndex(a,x):
    l=len(a)
    if l==0:
        return -1
    if a[0]==x:
        return 0
    smallerList=a[1:]
    smallerListOutput=FirstIndex(smallerList,x)
    if smallerListOutput==-1:
        return -1
    else:
        return smallerListOutput+1

from sys import setrecursionlimit
setrecursionlimit(11000)
n=int(input())
a=list(int(i) for i in input().strip().split(' '))
x=int(input())
r=FirstIndex(a,x)
print(r)


#Last Index Of Number Question
"""
Given an array of length N and an integer x, you need to find and return the last index of integer x present in the array. Return -1 if it is not present in the array.
Last index means - if x is present multiple times in the array, return the index at which x comes last in the array.
You should start traversing your array from 0, not from (N - 1).
Do this recursively. Indexing in the array starts from 0.

Input Format :
Line 1 : An Integer N i.e. size of array
Line 2 : N integers which are elements of the array, separated by spaces
Line 3 : Integer x

Output Format :
last index or -1
"""
Sample Input :
4
9 8 10 8
8
Sample Output :
3

Solution :

def LastIndex(a,x):
    l=len(a)
    if l==0:
        return -1
    smallerList=a[1:]
    smallerListOutput=LastIndex(smallerList,x)
    if smallerListOutput!= -1:
        return smallerListOutput+1
    else:
        if a[0]==x:
            return 0
        else:
            return -1

from sys import setrecursionlimit
setrecursionlimit(11000)
n=int(input())
a=list(int(i) for i in input().strip().split(' '))
x=int(input())
r=LastIndex(a,x)
print(r)





#Remove X
"""
Given a string, compute recursively a new string where all 'x' chars have been removed.

Input format :
String S

Output format :
Modified String
"""
Sample Input 1 :
xaxb
Sample Output 1:
ab

Sample Input 2 :
abc
Sample Output 2:
abc

Sample Input 3 :
xx
Sample Output 3:

Solution :

def removeX(s,x):
    if len(s)==0:
        return s

    smallOutput=removeX(s[1:],x)

    if s[0]==x:
        return smallOutput

    else:
        return s[0]+smallOutput

s=input()
r=removeX(s,'x')
print(r)


#Remove Duplicates Recursively
"""
Given a string S, remove consecutive duplicates from it recursively.

Input Format :
String S

Output Format :
Output string
"""
Sample Input 1 :
aabccba
Sample Output 1 :
abcba

Sample Input 2 :
xxxyyyzwwzzz
Sample Output 2 :
xyzwz

Solution :

def removeDuplicate(s):

    if len(s)==0 or len(s)==1:
        return s

    if s[0]==s[1]:
        smallOutput=removeDuplicate(s[1:])
        return smallOutput

    else:
        smallOutput=removeDuplicate(s[1:])
        return s[0]+smallOutput

s=input()
r=removeDuplicate(s)
print(r)


#Merge Sort
"""
Sort an array A using Merge Sort.
Change in the input array itself. So no need to return or print anything.

Input format :
Line 1 : Integer n i.e. Array size
Line 2 : Array elements (separated by space)

Output format :
Array elements in increasing order (separated by space)
"""
Sample Input 1 :
6
2 6 8 5 4 3
Sample Output 1 :
2 3 4 5 6 8

Sample Input 2 :
5
2 1 5 2 3
Sample Output 2 :
1 2 2 3 5

Solution :

def mergeSort(arr, start, end):
    size = end - start
    if size <= 1:
        return
    mid = (start + end) // 2
    mergeSort(arr, start, mid)
    mergeSort(arr, mid, end)

    # Merge Two Sorted Lists
    result = [0] * size
    i = start
    j = mid
    k = 0
    while (i < mid and j < end):
        if (arr[i] < arr[j]):
            result[k] = arr[i]
            k += 1
            i += 1
        else:
            result[k] = arr[j]
            k += 1
            j += 1
    while (i < mid):
        result[k] = arr[i]
        k += 1
        i += 1
    while (j < end):
        result[k] = arr[j]
        k += 1
        j += 1
    for i in range(0, size):
        arr[start + i] = result[i]


n = int(input())
arr = list(int(i) for i in input().strip().split(' '))
mergeSort(arr, 0, n)
for num in arr:
    print(num, end=" ")
print()


#Quick Sort
"""
Sort an array A using Quick Sort.
Change in the input array itself. So no need to return or print anything.

Input format :
Line 1 : Integer n i.e. Array size
Line 2 : Array elements (separated by space)

Output format :
Array elements in increasing order (separated by space)
"""
Sample Input 1 :
6
2 6 8 5 4 3
Sample Output 1 :
2 3 4 5 6 8

Sample Input 2 :
5
1 5 2 7 3
Sample Output 2 :
1 2 3 5 7

Solution :

def partition(a,si,ei):
    pivot=a[si]
    c=0
    for i in range(si,ei+1):
        if a[i] < pivot:
            c=c+1
    a[si+c],a[si]=a[si],a[si+c]
    pivot_index=si+c
    i=si
    j=ei
    while i < j :
        if (a[i]<pivot):
            i=i+1
        elif a[j] >= pivot:
            j=j-1
        else:
            a[i],a[j]=a[j],a[i]
            i = i + 1
            j = j - 1
    return pivot_index

def quick_sort(a,si,ei):
    if si>=ei:
        return
    pivot_index=partition(a,si,ei)
    quick_sort(a,si,pivot_index-1)
    quick_sort(a,pivot_index+1,ei)

n=int(input())
a=list(int(i) for i in input().strip().split(' '))
quick_sort(a,0,len(a)-1)
for x in a:
    print(x,end=" ")


#Tower Of Hanoi
"""
Tower of Hanoi is a mathematical puzzle where we have three rods and n disks. 
The objective of the puzzle is to move all disks from source rod to destination rod using third rod (say auxiliary). 
The rules are :
1) Only one disk can be moved at a time.
2) A disk can be moved only if it is on the top of a rod.
3) No disk can be placed on the top of a smaller disk.
Print the steps required to move n disks from source rod to destination rod.
Source Rod is named as 'a', auxiliary rod as 'b' and destination rod as 'c'.

Input Format :
Integer n

Output Format :
Steps in different lines (in one line print source and destination rod name separated by space)
"""
Sample Input 1 :
2
Sample Output 1 :
a b
a c
b c

Sample Input 2 :
3
Sample Output 2 :
a c
a b
c b
a c
b a
b c
a c

Solution :

def tower(n,a,b,c):

    if n==0:
        return

    if n==1:
        print(a,c )
        return

    tower(n-1,a,c,b)

    print(a,c)

    tower(n-1,b,a,c)

n=int(input())
tower(n,"a","b","c")





#Geometric Sum
"""
Given k, find the geometric sum i.e.
1 + 1/2 + 1/4 + 1/8 + ... + 1/(2^k)
using recursion.

Input format :
Integer k

Output format :
Geometric sum
"""
Sample Input 1 :
3
Sample Output 1 :
1.875

Sample Input 2 :
4
Sample Output 2 :
1.93750

Solution :

def gsum(s):
    if s==0:
        return 1
    cal=1/(2**s)
    r=gsum(s-1)
    ans=r+cal
    return ans
s=int(input())
x=gsum(s)
print("%.5f" %x)


#Check Palindrome (recursive)
"""
Check whether a given String S is a palindrome using recursion. Return true or false.

Input Format :
String S

Output Format :
'true' or 'false'
"""
Sample Input 1 :
racecar
Sample Output 1:
true

Sample Input 2 :
ninja
Sample Output 2:
false

Solution :

def Palindrome(str):
    size = len(str)
    if size <= 1:
        return True
    if str[0] != str[size-1]:
        return False
    return Palindrome(str[1:-1])

from sys import setrecursionlimit
setrecursionlimit(11000)
str = input()
if Palindrome(str):
    print('true')
else:
    print('false')


#Sum of digits (recursive)
"""
Write a recursive function that returns the sum of the digits of a given integer.

Input format :
Integer N

Output format :
Sum of digits of N
"""
Sample Input 1 :
12345
Sample Output 1 :
15

Sample Input 2 :
9
Sample Output 2 :
9

Solution :

def sumOfDigits(n):
    if n == 0:
        return 0

    smallAns = sumOfDigits(n // 10)
    return smallAns + n % 10

from sys import setrecursionlimit
setrecursionlimit(11000)
n = int(input())
print(sumOfDigits(n))


#Multiplication (Recursive)
"""
Given two integers M & N, calculate and return their multiplication using recursion.
You can only use subtraction and addition for your calculation. No other operators are allowed.

Input format :
Line 1 : Integer M
Line 2 : Integer N

Output format :
M x N
"""
Sample Input 1 :
3
5
Sample Output 1 :
15

Sample Input 2 :
4
0
Sample Output 2 :
0

Solution :

def multiply(m, n):
    if m == 0 or n == 0:
        return 0

    if n > 0:
        smallAns = multiply(m, n - 1)
        return smallAns + m

    else:
        smallAns = multiply(m, n + 1)
        return smallAns - m

from sys import setrecursionlimit
setrecursionlimit(11000)
m = int(input())
n = int(input())
print(multiply(m, n))


#Count Zeros
"""
Given an integer N, count and return the number of zeros that are present in the given integer using recursion.

Input Format :
Integer N

Output Format :
Number of zeros in N
"""
Sample Input 1 :
10204
Sample Output 1 :
2

Sample Input 2 :
708000
Sample Output 2 :
4

Solution :

def countZeros(n):
    if n < 0:
        n *= -1

    if n < 10:
        if n == 0:
            return 1
        return 0

    smallAns = countZeros(n // 10)
    if n % 10 == 0:
        smallAns += 1
    return smallAns

from sys import setrecursionlimit
setrecursionlimit(11000)
n = int(input())
print(countZeros(n))


#String to Integer
"""
Write a recursive function to convert a given string into the number it represents.
That is input will be a numeric string that contains only numbers, 
you need to convert the string into corresponding integer and return the answer.

Input format :
Numeric string S (string, Eg. "1234")

Output format :
Corresponding integer N (int, Eg. 1234)
"""
Sample Input 1 :
1231
Sample Output 1 :
1231

Sample Input 2 :
12567
Sample Output 2 :
12567

Solution :

def string_int(n):
    a=int(n)
    return a

n=input()
r=string_int(n)
print(r)


#Pair star
"""
Given a string S, compute recursively a new string where identical chars 
that are adjacent in the original string are separated from each other by a "*".

Input format :
String S

Output format :
Modified string
"""
Sample Input 1 :
hello
Sample Output 1:
hel*lo

Sample Input 2 :
aaaa
Sample Output 2 :
a*a*a*a

Solution :

def pairStar(Input, Output, i=0):
    Output = Output + Input[i]

    if (i == len(Input) - 1):
        print(Output)
        return;

    if (Input[i] == Input[i + 1]):
        Output = Output + '*';

    pairStar(Input, Output, i + 1);

if __name__ == "__main__":
    Input = input()
    Output = ""
    pairStar(Input, Output);


#Check AB
"""
Suppose you have a string, S, made up of only 'a's and 'b's. 
Write a recursive function that checks if the string was generated using the following rules:

a. The string begins with an 'a'
b. Each 'a' is followed by nothing or an 'a' or "bb"
c. Each "bb" is followed by nothing or an 'a'

If all the rules are followed by the given string, return true otherwise return false.

Input format :
String S

Output format :
'true' or 'false'
"""
Sample Input 1 :
abb
Sample Output 1 :
true

Sample Input 2 :
abababa
Sample Output 2 :
false

Solution :

def checkAB(str):
    if (len(str) == 0):
        return True

    if (str[0] == 'a'):
        if (len(str[1:]) > 1 and str[1:3] == 'bb'):
            return checkAB(str[3:])

        else:
            return checkAB(str[1:])

    else:
        return False

str = input()
if (checkAB(str)):
    print('true')
else:
    print('false')


#Staircase
"""
A child is running up a staircase with N steps, and can hop either 1 step, 2 steps or 3 steps at a time.
Implement a method to count how many possible ways the child can run up to the stairs.
You need to return number of possible ways W.

Input format :
Integer N

Output Format :
Integer W
"""
Sample Input 1 :
4
Sample Output 1 :
7

Sample Input 2 :
5
Sample Output 2 :
13

Solution :

def staircase(n):
    if (n < 3):
        return n

    if n == 3:
        return 4
    return staircase(n - 1) + staircase(n - 2) + staircase(n - 3)

n = int(input())
count = staircase(n)
print(count)





#Power Of A Number
"""
Write a program to find x to the power n (i.e. x^n). Take x and n from the user. You need to return the answer.
Do this recursively.

Input format :
Two integers x and n (separated by space)

Output Format :
x^n (i.e. x raise to the power n)
"""
Sample Input 1 :
 3 4
Sample Output 1 :
81

Sample Input 2 :
 2 5
Sample Output 2 :
32

Solution :

def Power(x, n):
    if n == 0:
        return 1

    smallAns = Power(x, n - 1)

    return smallAns * x

from sys import setrecursionlimit
setrecursionlimit(11000)
x, n = list(int(i) for i in input().strip().split(' '))
print(Power(x, n))


#Array Intersection
"""
Given two random integer arrays, print their intersection.
That is, print all the elements that are present in both the given arrays.
Input arrays can contain duplicate elements.

Note : Order of elements are not important

Input format :
Line 1 : Integer N, Array 1 Size
Line 2 : Array 1 elements (separated by space)
Line 3 : Integer M, Array 2 Size
Line 4 : Array 2 elements (separated by space)

Output format :
Print intersection elements in different lines
"""
Sample Input 1 :
6
2 6 8 5 4 3
4
2 3 4 7
Sample Output 1 :
2
4
3

Sample Input 2 :
4
2 6 1 2
5
1 2 3 4 2
Sample Output 2 :
2
2
1

Solution :

def intersection(arr1, arr2):
    arr1.sort()
    arr2.sort()
    i = 0
    j = 0

    while i < len(arr1) and j < len(arr2):
        if arr1[i] < arr2[j]:
            i += 1
        elif arr1[i] > arr2[j]:
            j += 1
        else:
            print(arr1[i])
            i += 1
            j += 1

n1 = int(input())
arr1 = list(int(i) for i in input().strip().split(' '))
n2 = int(input())
arr2 = list(int(i) for i in input().strip().split(' '))
intersection(arr1, arr2)


#Array Equilibrium Index
"""
Find and return the equilibrium index of an array. 
Equilibrium index of an array is an index i such that,
the sum of elements at indices less than i is equal to the sum of elements at indices greater than i.
Element at index i is not included in either part.
If more than one equilibrium index is present, you need to return the first one. 
And return -1 if no equilibrium index is present.

Input format :
Line 1 : Size of input array
Line 2 : Array elements (separated by space)
"""
Sample Input :
7
-7 1 5 2 -4 3 0
Sample Output :
3

Solution :

def equilibrium(arr):
    total_sum = sum(arr)
    leftsum = 0
    for i, num in enumerate(arr):

        total_sum -= num

        if leftsum == total_sum:
            return i
        leftsum += num

    return -1

n1 = int(input())
arr = list(int(i) for i in input().strip().split(' '))
print(equilibrium(arr))


#Find the Unique Element
"""
Given an integer array of size 2N + 1. In this given array, 
N numbers are present twice and one number is present only once in the array.
You need to find and return that number which is unique in the array.

Note : Given array will always contain odd number of elements.

Input format :
Line 1 : Array size i.e. 2N+1
Line 2 : Array elements (separated by space)

Output Format :
Unique element present in the array
"""
Sample Input :
7
2 3 1 6 3 6 2
Sample Output :
1

Solution :

def find_unique(li):
    ele = li[0]
    for i in range(1, len(li)):
        ele = ele ^ li[i]
    return ele

n = int(input())
li = [int(x) for x in input().split()]
unique = find_unique(li)
print(unique)


#Duplicate in array
"""
Given an array of integers of size n which contains numbers from 0 to n - 2. 
Each number is present at least once. That is, if n = 5, 
numbers from 0 to 3 is present in the given array at least once and one number is present twice. 
You need to find and return that duplicate number present in the array.
Assume, duplicate number is always present in the array.

Input format :
Line 1 : Size of input array
Line 2 : Array elements (separated by space)

Output Format :
Duplicate element
"""
Sample Input:
9
0 7 2 5 4 7 1 3 6
Sample Output:
7

Solution :

def DuplicateNumber(arr):
    n = len(arr) - 2
    totalSum = 0

    for i in arr:
        totalSum += i

    #sum of n natural numbers
    sum = int(n*(n+1)/2)
    return totalSum - sum

n=int(input())
arr=list(int(i) for i in input().strip().split(' '))
ans=DuplicateNumber(arr)
print(ans)


#Pair sum in array
"""
Given a random integer array A and a number x. 
Find and print the pair of elements in the array which sum to x.
Array A can contain duplicate elements.
While printing a pair, print the smaller element first.
That is, if a valid pair is (6, 5) print "5 6". 
There is no constraint that out of 5 pairs which have to be printed in 1st line. 
You can print pairs in any order, just be careful about the order of elements in a pair.

Input format :
Line 1 : Integer N (Array size)
Line 2 : Array elements (separated by space)
Line 3 : Integer x

Output format :
Line 1 : Pair 1 elements (separated by space)
Line 2 : Pair 2 elements (separated by space)
Line 3 : and so on
"""
Sample Input:
9
1 3 6 2 5 4 3 2 4
7
Sample Output :
1 6
3 4
3 4
2 5
2 5
3 4
3 4

Solution :
n = int(input())
a = [int(x) for x in input().split()]
sum = int(input())

for i in range (len(a)):
    for j in range (i+1,len(a)):
        if a[i]+a[j]==sum:

            if(a[i]<a[j]):
                print(a[i]," ",a[j])

            else:
                print(a[j]," ",a[i])


#Triplet sum
"""
Given a random integer array and a number x. 
Find and print the triplets of elements in the array which sum to x.
While printing a triplet, print the smallest element first.
That is, if a valid triplet is (6, 5, 10) print "5 6 10". 
There is no constraint that out of 5 triplets which have to be printed on 1st line. 
You can print triplets in any order, just be careful about the order of elements in a triplet.

Input format :
Line 1 : Integer N (Array Size)
Line 2 : Array elements (separated by space)
Line 3 : Integer x

Output format :
Line 1 : Triplet 1 elements (separated by space)
Line 2 : Triplet 3 elements (separated by space)
Line 3 : and so on
"""
Sample Input:
7
1 2 3 4 5 6 7
12
Sample Output ;
1 4 7
1 5 6
2 3 7
2 4 6
3 4 5

Solution :

def count(arr, x):
    counter = 0
    for i in arr:

        if i == x:
            counter += 1

    return counter

def tripletSum(arr, x):
    arr.sort()

    for k in range(len(arr) - 2):
        i, j = k + 1, len(arr) - 1
        while j > i:

            if arr[i] + arr[j] + arr[k] == x:
                dup_j = count(arr[i + 1:], arr[j])

                for z in range(dup_j):
                    print(arr[k], arr[i], arr[j])

                i += 1

            elif arr[i] + arr[j] + arr[k] > x:
                j -= 1

            elif arr[i] + arr[j] + arr[k] < x:
                i += 1

n = int(input())
arr = list(int(i) for i in input().strip().split(' '))
sum = int(input())
tripletSum(arr, sum)


#Rotate array
"""
You have been given a random integer array/list(ARR) of size N. 
Write a function that rotates the given array/list by D elements(towards the left).

Note:
Change in the input array/list itself. You don't need to return or print the elements.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Third line contains the value of 'D' by which the array/list needs to be rotated.

Output Format :
For each test case, print the rotated array/list in a row separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
1 2 3 4 5 6 7
2
Sample Output 1:
3 4 5 6 7 1 2

Sample Input 2:
2
7
1 2 3 4 5 6 7
0
4
1 2 3 4
2
Sample Output 2:
1 2 3 4 5 6 7
3 4 1 2

Solution :

def leftRotate(arr, d, n):
    for i in range(d):
        leftRotatebyOne(arr, n)

def leftRotatebyOne(arr, n):
    temp = arr[0]
    for i in range(n - 1):
        arr[i] = arr[i + 1]
    arr[n - 1] = temp

def printArray(arr, size):
    for i in range(size):
        print("%d" % arr[i], end=" ")

n = int(input())
arr = [int(x) for x in input().split()]
d = int(input())
leftRotate(arr, d, n)
printArray(arr, n)





#Length of LL
"""
For a given singly linked list of integers, find and return its length. Do it using an iterative method.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.
First and the only line of each test case or query contains elements of the singly linked list separated by a single space.

Remember/Consider :
While specifying the list elements for input, -1 indicates the end of the singly linked list and hence,
would never be a list element.

Output format :
For each test case, print the length of the linked list.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
1
3 4 5 2 6 1 9 -1
Sample Output 1 :
7

Sample Input 2 :
2
10 76 39 -3 2 9 -23 9 -1
-1
Sample Output 2 :
8
0

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def findlength(head):
    if head == None:
        return 0

    if head.next == None:
        return 1

    return findlength(head.next) + 1

def ll(arr):

    if arr == []:
        return None

    head = Node(arr[0])
    last = head

    for data in arr[1:]:
        last.next = Node(data)
        last = last.next

    return head

from sys import setrecursionlimit
setrecursionlimit(11000)

arr = list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
len = findlength(l)
print(len)


#Print ith node
"""
For a given a singly linked list of integers and a position 'i', print the node data at the 'i-th' position.

Note :
Assume that the Indexing for the singly linked list always starts from 0.
If the given position 'i',  is greater than the length of the given singly linked list, then don't print anything.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
The first line of each test case or query contains the elements of the singly linked list separated by a single space.
The second line contains the value of 'i'. It denotes the position in the given singly linked list.

Remember/Consider :
While specifying the list elements for input, 
-1 indicates the end of the singly linked list and hence, would never be a list element.

Output format :
For each test case, print the node data at the 'i-th' position of the linked list(if exists).
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
1
3 4 5 2 6 1 9 -1
3
Sample Output 1 :
2

Sample Input 2 :
2
3 4 5 2 6 1 9 -1
0
9 8 4 0 7 8 -1
3
Sample Output 2 :
3
0

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def ithNode(head, i):
    count = 0
    current = head
    while count < i and current != None:
        current = current.next
        count = count + 1
    return current

def ll(arr):
    if arr == []:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

from sys import setrecursionlimit

setrecursionlimit(11000)
arr = list(int(i) for i in input().strip().split(' '))
i = int(input())
l = ll(arr[:-1])
node = ithNode(l, i)
if node:
    print(node.data)


#Delete node
"""
You have been given a linked list of integers. 
Your task is to write a function that deletes a node from a given position, 'pos'.\

Note :
Assume that the Indexing for the linked list always starts from 0.
If the position is greater than or equal to the length of the linked list, 
you should return the same linked list without any change.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
The first line of each test case or query contains the elements of the linked list separated by a single space. 
The second line contains the integer value of 'pos'. 
It denotes the position in the linked list from where the node has to be deleted.

Output format :
For each test case/query, print the resulting linked list of integers in a row, separated by a single space.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
1
3 4 5 2 6 1 9 -1
3
Sample Output 1 :
3 4 5 6 1 9

Sample Input 2 :
2
3 4 5 2 6 1 9 -1
0
10 20 30 40 50 60 -1
7
Sample Output 2 :
4 5 2 6 1 9
10 20 30 40 50 60

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def deleteRec(head, i):
    if (i < 0) :
        return head
    if (head == None):
        return None
    if (i == 0) :
        res = head.next
        return res
    head.next = deleteRec(head.next, i-1 )
    return head
    pass

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

from sys import setrecursionlimit
setrecursionlimit(11000)

arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
i=int(input())
l = deleteRec(l, i)
printll(l)


#Find a Node in Linked List
"""
You have been given a singly linked list of integers. 
Write a function that returns the index/position of an integer data denoted by 'N'(if it exists). -1 otherwise.

Note :
Assume that the Indexing for the singly linked list always starts from 0.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
The first line of each test case or query contains the elements of the singly linked list separated by a single space. 
The second line contains the integer value 'N'. 
It denotes the data to be searched in the given singly linked list.

Remember/Consider :
While specifying the list elements for input, -1 indicates the end of the singly linked list and hence, 
would never be a list element.

Output format :
For each test case/query, print the index/position of 'N' in the singly linked list. -1, otherwise.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
2
3 4 5 2 6 1 9 -1
5
10 20 30 40 50 60 70 -1
6
Sample Output 1 :
2
-1

Sample Input 2 :
1
3 4 5 2 6 1 9 -1
6
Sample Output 2 :
4
Explanation for Sample Input 2 :
For the given singly linked list, considering the indices starting from 0,
progressing in a left to right manner with a jump of 1, then the N = 6 appears at position 4.

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def findNode(head,number, index):
    if (head == None):
        return -1
    if (head.data == number) :
        return index
    return findNode(head.next,number, index+1)

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

from sys import setrecursionlimit
setrecursionlimit(11000)

arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
numberToFind=int(input())
index = findNode(l,numberToFind, 0)
print(index)


#AppendLastNToFirst
"""
You have been given a singly linked list of integers along with an integer 'N'. 
Write a function to append the last 'N' nodes towards the front of the singly linked list and returns the new head to the list.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
The first line of each test case or query contains the elements of the singly linked list separated by a single space. 
The second line contains the integer value 'N'. It denotes the number of nodes to be moved from last to the front of the singly linked list.

Remember/Consider :
While specifying the list elements for input, -1 indicates the end of the singly linked list and hence, would never be a list element.

Output format :
For each test case/query, print the resulting singly linked list of integers in a row, separated by a single space.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
2
1 2 3 4 5 -1
3
10 20 30 40 50 60 -1
5
Sample Output 1 :
3 4 5 1 2
20 30 40 50 60 10

Sample Input 2 :
1
10 6 77 90 61 67 100  -1
4
Sample Output 2 :
90 61 67 100 10 6 77
Explanation to Sample Input 2 :
We have been required to move the last 4 nodes to the front of the list. Here, "90->61->67->100" is the list which represents the last 4 nodes.
When we move this list to the front then the remaining part of the initial list which is, "10->6->77" is attached after 100. Hence,
the new list formed with an updated head pointing to 90.

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def length(head):
    count = 0
    while head is not None:
        head = head.next
        count += 1

    return count

def append_LinkedList(head, n):
    if head == None or head.next == None:
        return head
    curr = head
    temp2 = head
    count = 0
    l = length(head)
    while count < l - n - 1:
        curr = curr.next
        count += 1
    temp1 = curr.next
    head = temp1
    curr.next = None
    while temp1.next != None:
        temp1 = temp1.next
    temp1.next = temp2
    return head

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

arr = list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
i = int(input())
l = append_LinkedList(l, i)
printll(l)


#Eliminate duplicates from LL
"""
You have been given a singly linked list of integers where the elements are sorted in ascending order. 
Write a function that removes the consecutive duplicate values such that the given list only contains unique elements and returns the head to the updated list.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
The first and the only line of each test case or query contains the elements(in ascending order) of the singly linked list separated by a single space.

Remember/Consider :
While specifying the list elements for input, -1 indicates the end of the singly linked list and hence, would never be a list element.

Output format :
For each test case/query, print the resulting singly linked list of integers in a row, separated by a single space.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
1
1 2 3 3 4 3 4 5 4 5 5 7 -1
Sample Output 1 :
1 2 3 4 3 4 5 4 5 7

Sample Input 2 :
2
10 20 30 40 50 -1
10 10 10 10 -1
Sample Output 2 :
10 20 30 40 50
10

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def eliminate_duplicate(head):
    temp = head
    if temp is None:
        return
    while temp.next is not None:
        if temp.data == temp.next.data:
            new = temp.next.next
            temp.next = None
            temp.next = new
        else:
            temp = temp.next
    return head

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

arr = list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
l = eliminate_duplicate(l)
printll(l)


#Print Reverse LinkedList
"""
You have been given a singly linked list of integers. Write a function to print the list in a reverse order.
To explain it further, you need to start printing the data from the tail and move towards the head of the list, 
printing the head data at the end.

Note :
You can’t change any of the pointers in the linked list, just print it in the reverse order.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. Then the test cases follow.
The first and the only line of each test case or query contains the elements of the singly linked list separated by a single space.

Remember/Constraints :
While specifying the list elements for input, -1 indicates the end of the singly linked list and hence, would never be a list element.

Output format :
For each test case, print the singly linked list of integers in a reverse fashion, in a row, separated by a single space.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
1
1 2 3 4 5 -1
Sample Output 1 :
5 4 3 2 1

Sample Input 2 :
2
1 2 3 -1
10 20 30 40 50 -1
Sample Output 2 :
3 2 1
50 40 30 20 10

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def reverse(head):
    def __init__(self):
        head = None
    prev = None
    current =head
    while(current is not None):
        next = current.next
        current.next = prev
        prev = current
        current = next
    head = prev
    return head

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head
def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

from sys import setrecursionlimit
setrecursionlimit(10000)
arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
r=reverse(l)
printll(r)


#Palindrome LinkedList
"""
You have been given a head to a singly linked list of integers. Write a function check to whether the list given is a 'Palindrome' or not.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. Then the test cases follow.
First and the only line of each test case or query contains the the elements of the singly linked list separated by a single space.

Remember/Consider :
While specifying the list elements for input, -1 indicates the end of the singly linked list and hence, would never be a list element.

Output format :
For each test case, the only line of output that print 'true' if the list is Palindrome or 'false' otherwise.
"""
Sample Input 1 :
1
9 2 3 3 2 9 -1
Sample Output 1 :
true

Sample Input 2 :
2
0 2 3 2 5 -1
-1
Sample Output 2 :
false
true
Explanation for the Sample Input 2 :
For the first query, it is pretty intuitive that the the given list is not a palindrome, hence the output is 'false'.
For the second query, the list is empty. An empty list is always a palindrome , hence the output is 'true'.

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.last_node = None

    def append(self, data):
        if self.last_node is None:
            self.head = Node(data)
            self.last_node = self.head
        else:
            self.last_node.next = Node(data)
            self.last_node = self.last_node.next

    def get_prev_node(self, ref_node):
        current = self.head
        while (current and current.next != ref_node):
            current = current.next
        return current

def is_palindrome(llist):
    start = llist.head
    end = llist.last_node
    while (start != end and end.next != start):
        if start.data != end.data:
            return False
        start = start.next
        end = llist.get_prev_node(end)
    return True

a_llist = LinkedList()

data_list = input().split()
for data in data_list:
    if int(data) != -1:
        a_llist.append(int(data))

if is_palindrome(a_llist):
    print('true')
else:
    print('false')




#Reverse LL(Iterative)
"""
Given a linked list, reverse it iteratively.
You don't need to print the elements, just reverse the LL duplicates and return the head of updated LL.

Input format : Linked list elements (separated by space and terminated by -1)`
"""
Sample Input :
1 2 3 4 5 -1
Sample Output :
5 4 3 2 1

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def reverse(head):
    def __init__(self):
        head = None
    prev = None
    current =head
    while(current is not None):
        next = current.next
        current.next = prev
        prev = current
        current = next
    head = prev
    return head

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head
def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

from sys import setrecursionlimit
setrecursionlimit(10000)
arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
r=reverse(l)
printll(r)


#Midpoint of Linked list
"""
Given a linked list, find and return the midpoint.
If the length of linked list is even, return the first mid point.

Input format : Linked list elements (separated by space and terminated by -1)`
"""
Sample Input 1 :
1 2 3 4 5 -1
Sample Output 1 :
3

Sample Input 2 :
1 2 3 4 -1
Sample Output 2 :
2

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def midpoint_linkedlist(head):
    slow=head
    fast=head
    while (fast.next!=None) and (fast.next.next!=None):
        slow=slow.next
        fast=fast.next.next
    return slow

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
node = midpoint_linkedlist(l)
if node:
    print(node.data)


#Merge two sorted LL
"""
Given two linked lists sorted in increasing order. 
Merge them in such a way that the result list is also sorted (in increasing order).
Try solving with O(1) auxiliary space (in-place). You just need to return the head of new linked list, 
don't print the elements.

Input format :
Line 1 : Linked list 1 elements of length n (separated by space and terminated by -1)
Line 2 : Linked list 2 elements of length m (separated by space and terminated by -1)

Output format :
Merged list elements (separated by space)
"""
Sample Input :
 2 5 8 12 -1
 3 6 9 -1
Sample Output :
 2 3 5 6 8 9 12

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def merge(head1,head2):
    temp = None
    if head1 is None:
        return head2
    if head2 is None:
        return head1
    if head1.data <= head2.data:
        temp = head1
        temp.next = merge(head1.next, head2)
    else:
        temp = head2
        temp.next = merge(head1, head2.next)
    return temp

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

from sys import setrecursionlimit
setrecursionlimit(50000)
arr1=list(int(i) for i in input().strip().split(' '))
arr2=list(int(i) for i in input().strip().split(' '))
l1 = ll(arr1[:-1])
l2 = ll(arr2[:-1])
l = merge(l1, l2)
printll(l)


#Code : Merge Sort
"""
Sort a given linked list using Merge Sort.
You don't need to print the elements, just sort the elements and return the head of updated LL.

Input format :
Linked list elements (separated by space and terminated by -1)

Output format :
Updated LL elements (separated by space)
"""
Sample Input :
1 4 5 2 -1
Sample Output :
1 2 4 5

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

def getMiddle(head):
    if (head == None):
        return head
    slow = head
    fast = head
    while (fast.next != None and fast.next.next != None):
        slow = slow.next
        fast = fast.next.next
    return slow

def sortedMerge(a, b):
    result = None
    if a == None:
        return b
    if b == None:
        return a
    if a.data <= b.data:
        result = a
        result.next = sortedMerge(a.next, b)
    else:
        result = b
        result.next = sortedMerge(a, b.next)
    return result

def mergeSort(head):
    if head == None or head.next == None:
        return head
    middle = getMiddle(head)
    nexttomiddle = middle.next
    middle.next = None
    left = mergeSort(head)
    right = mergeSort(nexttomiddle)
    sortedlist = sortedMerge(left, right)
    return sortedlist

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

arr = list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
l = mergeSort(l)
printll(l)


#Find a node in LL (recursive)
"""
Given a linked list and an integer n you need to find and return index where n is present in the LL. 
Do this recursively.
Return -1 if n is not present in the LL.
Indexing of nodes starts from 0.

Input format :
Line 1 : Linked list elements (separated by space and terminated by -1)
Line 2 : Integer n

Output format :
Index
"""
Sample Input 1 :
3 4 5 2 6 1 9 -1
5
Sample Output 1 :
2

Sample Input 2 :
3 4 5 2 6 1 9 -1
6
Sample Output 2 :
4

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def findNode(head,number, index):
    if (head == None):
        return -1
    if (head.data == number) :
        return index
    return findNode(head.next,number, index+1)

def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

from sys import setrecursionlimit
setrecursionlimit(11000)
arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
numberToFind=int(input())
index = findNode(l,numberToFind, 0)
print(index)


#Even after Odd LinkedList
"""
Arrange elements in a given Linked List such that, all even numbers are placed after odd numbers. 
Respective order of elements should remain same.
Note: Input and Output has already managed for you. You don't need to print the elements, 
instead return the head of updated LL.

Input format:
Linked list elements (separated by space and terminated by -1)

Output format:
Print the elements of updated Linked list. 
"""
Sample Input 1 :
1 4 5 2 -1
Sample Output 1 :
1 5 4 2

Sample Input 2 :
1 11 3 6 8 0 9 -1
Sample Output 2 :
1 11 3 9 6 8 0

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def arranged_LL(head):
    oddH=None
    oddT=None
    evenH=None
    evenT=None
    if head is None or head.next is None:
        return head
    while head!=None:
        if head.data%2==1:
            if oddH is None:
                oddH=head
                oddT=head
                head=head.next
            else:
                oddT.next=head
                oddT=oddT.next
                head=head.next
        else:
            if evenH is None:
                evenH=head
                evenT=head
                head=head.next
            else:
                evenT.next=head
                evenT=evenT.next
                head=head.next
    if oddH is not None:
        if evenH is not None:
            oddT.next=evenH
            evenT.next=None
        else:
            oddT.next=None
        return oddH
    else:
        evenT.next=None
        return evenH
def ll(arr):
    if len(arr)==0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

arr=list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
l = arranged_LL(l)
printll(l)


#Delete every N nodes
"""
Given a linked list and two integers M and N. Traverse the linked list such that you retain M nodes then delete next N nodes, 
continue the same until end of the linked list. That is, in the given linked list you need to delete N nodes after every M nodes.

Input format :
Line 1 : Linked list elements (separated by space and terminated by -1)
Line 2 : M
Line 3 : N
"""
Sample Input 1 :
1 2 3 4 5 6 7 8 -1
2
2
Sample Output 1 :
1 2 5 6

Sample Input 2 :
1 2 3 4 5 6 7 8 -1
2
3
Sample Output 2 :
1 2 6 7

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def skipMdeleteN(head, M, N):
    if head is None:
        return

    t1 = head
    i = 0
    j = 0
    while i < M - 1:
        if t1 is not None:
            t1 = t1.next
        else:
            return
        i += 1

    while j < N:
        if t1.next is not None:
            t1.next = t1.next.next
        else:
            return
        j += 1

    t2 = t1.next

    skipMdeleteN(t2, M, N)
    return head

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

arr = list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
m = int(input())
n = int(input())
l = skipMdeleteN(l, m, n)
printll(l)


#Swap two Node of LL
"""
Given a linked list, i & j, swap the nodes that are present at i & j position in the LL. 
You need to swap the entire nodes, not just the data.
Indexing starts from 0. You don't need to print the elements, just swap and return the head of updated LL.
Assume i & j given will be within limits. And i can be greater than j also.

Input format :
Line 1 : Linked list elements (separated by space and terminated by -1)
Line 2 : i and j (separated by space)
"""
Sample Input 1 :
3 4 5 2 6 1 9 -1
3 4
Sample Output 1 :
3 4 5 6 2 1 9

Sample Input 2 :
3 4 5 2 6 1 9 -1
2 4
Sample Output 2 :
3 4 6 2 5 1 9

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def swap_nodes(head, i, j):
    curr = head
    prev = previ = curri = prevj = currj = None
    count = 0
    while curr != None:
        if count == i:
            previ = prev
            curri = curr
        elif count == j:
            prevj = prev
            currj = curr
        prev = curr
        curr = curr.next
        count += 1
    if (curri == None or currj == None):
        return

    if previ == None:
        head = currj
    else:
        previ.next = currj

    if prevj == None:
        head = curri
    else:
        prevj.next = curri

    curr = curri.next
    curri.next = currj.next
    currj.next = curr
    return head

    pass

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

arr = list(int(i) for i in input().strip().split(' '))
l = ll(arr[:-1])
i, j = list(int(i) for i in input().strip().split(' '))
l = swap_nodes(l, i, j)
printll(l)


#kReverse
"""
Implement kReverse( int k ) in a linked list i.e. you need to reverse first K elements,
then reverse next k elements and join the linked list and so on.
Indexing starts from 0. If less than k elements left in the last, you need to reverse them as well. 
If k is greater than length of LL, reverse the complete LL.
You don't need to print the elements, just return the head of updated LL.

Input format :
Line 1 : Linked list elements (separated by space and terminated by -1)
Line 2 : k
"""
Sample Input 1 :
1 2 3 4 5 6 7 8 9 10 -1
4
Sample Output 1 :
4 3 2 1 8 7 6 5 10 9

Sample Input 2 :
1 2 3 4 5 -1
2
Sample Output 2 :
2 1 4 3 5

Sample Input 3 :
1 2 3 4 5 6 7 -1
3
Sample Output 3 :
3 2 1 6 5 4 7

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def kReverse(head, n):
    current = head
    next = None
    prev = None
    count = 0
    while (current is not None and count < n):
        next = current.next
        current.next = prev
        prev = current
        current = next
        count += 1
    if next is not None:
        head.next = kReverse(next, n)
    return prev

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

# Read the link list elements including -1
arr = list(int(i) for i in input().strip().split(' '))
# Create a Linked list after removing -1 from list
l = ll(arr[:-1])
i = int(input())
l = kReverse(l, i)
printll(l)


#Bubble Sort (Iterative) LinkedList
"""
Sort a given linked list using Bubble Sort (iteratively). While sorting, you need to swap the entire nodes, 
not just the data.
You don't need to print the elements, just sort the elements and return the head of updated LL.

Input format : Linked list elements (separated by space and terminated by -1)`
"""
Sample Input :
1 4 5 2 -1
Sample Output :
1 2 4 5

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def getMiddle(head):
    if (head == None):
        return head
    slow = head
    fast = head
    while (fast.next != None and fast.next.next != None):
        slow = slow.next
        fast = fast.next.next
    return slow

def sortedMerge(a, b):
    result = None
    if a == None:
        return b
    if b == None:
        return a
    if a.data <= b.data:
        result = a
        result.next = sortedMerge(a.next, b)
    else:
        result = b
        result.next = sortedMerge(a, b.next)
    return result

def mergeSort(head):
    if head == None or head.next == None:
        return head
    middle = getMiddle(head)
    nexttomiddle = middle.next
    middle.next = None
    left = mergeSort(head)
    right = mergeSort(nexttomiddle)
    sortedlist = sortedMerge(left, right)
    return sortedlist

def ll(arr):
    if len(arr) == 0:
        return None
    head = Node(arr[0])
    last = head
    for data in arr[1:]:
        last.next = Node(data)
        last = last.next
    return head

def printll(head):
    while head:
        print(head.data, end=' ')
        head = head.next
    print()

# Read the link list elements including -1
from sys import setrecursionlimit

setrecursionlimit(11000)
arr = list(int(i) for i in input().strip().split(' '))
# Create a Linked list after removing -1 from list
l = ll(arr[:-1])
l = mergeSort(l)
printll(l)



#Code : Stack Using LL
"""
You need to implement a Stack class using linked list.
The data members should be private.
Implement the following public functions :

1. Constructor -
Initialises the data member (i.e. head to null).

2. push :
This function should take one argument of type T and has return type void.
This function should insert an element in the stack. Time complexity should be O(1).

3. pop :
This function takes no input arguments and has return type T.
This should removes the last element which is entered and return that element as an answer.
Time complexity should be O(1).

4. top :
This function takes no input arguments and has return type T.
This should return the last element which is entered and return that element as an answer.
Time complexity should be O(1).

5. size :
Return the size of stack i.e. count of elements which are present ins stack right now.
Time complexity should be O(1).

6. isEmpty :
Checks if the stack is empty or not. Return true or false.
"""
Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class StackUsingLL:

    def __init__(self):
        self.__head = None
        self.__size = 0

    def push(self, data):
        newNode = Node(data)
        newNode.next = self.__head
        self.__head = newNode
        self.__size = self.__size + 1

    def pop(self):
        if self.isEmpty() is True:
            return 0
        data = self.__head.data
        self.__head = self.__head.next
        self.__size = self.__size - 1
        return data

    # Return 0 if stack is empty. Don't display any other message

    def top(self):
        if self.isEmpty() is True:
            return 0
        data = self.__head.data
        return data

    # Return 0 if stack is empty. Don't display any other message

    def isEmpty(self):
        return self.getSize() == 0

    def getSize(self):
        return self.__size

li = [int(ele) for ele in input().split()]
s = StackUsingLL()
i = 0
while i < len(li):
    choice = li[i]
    if choice == -1:
        break
    elif choice == 1:
        s.push(li[i + 1])
        i += 1
    elif choice == 2:
        ans = s.pop()
        if ans != 0:
            print(ans)
        else:
            print(-1)
    elif choice == 3:
        ans = s.top()
        if ans != 0:
            print(ans)
        else:
            print(-1)
    elif choice == 4:
        print(s.getSize())
    elif choice == 5:
        if (s.isEmpty()):
            print('true')
        else:
            print('false')
    i += 1


#Balanced Paranthesis
"""
Given a string expression, check if brackets present in the expression are balanced or not. 
Brackets are balanced if the bracket which opens last, closes first.
You need to return true if it is balanced, false otherwise.

Note: This problem was asked in initial rounds in Facebook
"""
Sample Input 1 :
{ a + [ b+ (c + d)] + (e + f) }
Sample Output 1 :
true

Sample Input 2 :
{ a + [ b - c } ]
Sample Output 2 :
false

Solution :

def checkBalanced(expr):
    s=[]
    for char in expr:
        if char in '({[':
            s.append(char)
        elif char is ')':
            if(not s or s[-1]!='('):
                return False
            s.pop()
        elif char is '}':
            if(not s or s[-1]!='{'):
                return False
            s.pop()
        elif char is ']':
            if(not s or s[-1]!='['):
                return False
            s.pop()
    if (not s):
        return True
    return False

exp=input()
if checkBalanced(exp):
    print('true')
else:
    print('false')


#Reverse Stack
"""
Reverse a given Stack with the help of another empty stack. Two stacks will be given. 
Out of which first contains some integers and second one is empty. 
You need to reverse the first one using second stack. Change in the given first stack itself.

Note : You don't need to print or return the stack, 
just reverse the given stack and it will be printed internally.

Input format :
Line 1 : Size of Stack
Line 2 : Stack elements (separated by space)
"""
Sample Input :
4
1 2 3 4     (4 is at top)
Sample Output :
1 2 3 4    (1 is at top)

Solution :

def reverseStack(s1, s2):
    if (len(s1) <= 1):
        return
    while (len(s1) != 1):
        ele = s1.pop()
        s2.append(ele)
    lastEle = s1.pop()
    while (len(s2) != 0):
        ele = s2.pop()
        s1.append(ele)
    reverseStack(s1, s2)
    s1.append(lastEle)

from sys import setrecursionlimit
setrecursionlimit(11000)
n = int(input())
s1 = [int(ele) for ele in input().split()]
s2 = []
reverseStack(s1, s2)
while (len(s1) != 0):
    print(s1.pop(), end=' ')


#Check redundant brackets
"""
Given a string mathematical expression, return true if redundant brackets are present in the expression. 
Brackets are redundant if there is nothing inside the bracket or more than one pair of brackets are present.
Assume the given string expression is balanced and contains only one type of bracket i.e. ().

Note: You will not get partial score for this problem. You will get marks only if all test cases are passed.

Input Format :
String s (Expression)

Output Format :
true or false
"""
Sample Input 1:
((a + b))
Sample Output 1:
true

Sample Input 2:
(a+b)
Sample Output 2:
false

Solution :

def checkRedundancy(Str):
    st = []
    for ch in Str:
        if (ch == ')'):
            top = st[-1]
            st.pop()
            flag = True
            while (top != '('):
                if (top == '+' or top == '-' or top == '*' or top == '/'):
                    flag = False
                top = st[-1]
                st.pop()
            if (flag == True):
                return True
        else:
            st.append(ch)
    return False
def findRedundant(Str):
    ans = checkRedundancy(Str)
    if (ans == True):
        print("true")
    else:
        print("false")
if __name__ == '__main__':
    Str =input()
    findRedundant(Str)


#Stock Span
"""
The span si of a stock’s price on a certain day i is the minimum number of consecutive days (up to the current day) the price of the stock has been less than its price on that ith day. 
If for a particular day, if no stock price is greater then just count the number of days till 0th day including current day.
For eg. if given price array is {3, 6, 8, 1, 2}, span for 4th day (which has price 2) is 2 because minimum count of consecutive days (including 4th day itself) from current day which has price less than 4th day is 2 (i.e. day 3 & 4). 
Similarly, span for 2nd day is 3 because no stock price in left is greater than 2nd day's price. So count is 3 till 0th day.
Given an input array with all stock prices, you need to return the array with corresponding spans of each day.

Note : Try doing it in O(n).

Input format :
Line 1 : Integer n, Arrays Size
Line 2 : Price for n days (separated by space). It can contain duplicate values`

Output format :
Return an array that contain span for each day
"""
Sample Input 1 :
8
60 70 80 100 90 75 80 120
Sample Output 1 :
1 2 3 4 1 1 2 8

Sample Input 2 :
 4
 1 1 1 1
Sample Output 2 :
1 1 1 1

Solution :

def stockSpan(price, n):
    span = []
    span.append(1)
    st = []
    st.append(0)

    for i in range(1, n):
        while len(st) > 0 and price[st[-1]] < price[i]:
            st.pop()
        if len(st) <= 0:
            span.append(i + 1)
        else:
            span.append(i - st[-1])
        st.append(i)

    return span

n = int(input())
price = [int(x) for x in input().split()]
spans = stockSpan(price, n)
for ele in spans:
    print(ele, end=' ')


#Minimum bracket Reversal
"""
Given a string expression which consists only ‘}’ and ‘{‘. The expression may not be balanced. 
You need to find the minimum number of bracket reversals which are required to make the expression balanced.
Return -1 if the given expression can't be balanced.

Input Format :
String S

Output Format :
Required count
"""
Sample Input 1 :
{{{
Sample Output 1 :
-1

Sample Input 2 :
{{{{}}
Sample Output 2 :
1

Solution :

def countBracketReversals(string):
    if(len(string) == 0):
        return 0

    if(len(string)%2 != 0):
        return -1

    s = []
    for char in string:

        if char == '{':
            s.append(char)

        else:
            if(len(s) > 0 and s[-1] == '{'):
                s.pop()

            else:
                s.append(char)
    count = 0

    while(len(s) != 0):
        c1 = s.pop()
        c2 = s.pop()

        if c1!=c2:
            count+=2

        else:
            count+=1

    return count

string = input()
ans = countBracketReversals(string)
print(ans)




#Queue Using LL
"""
You need to implement a Queue class using linked list.
All the required data members should be private.

Implement the following public functions :

1. Constructor -
Initialises the data members.

2. enqueue :
This function should take one argument of type T and has return type void.
This function should insert an element in the queue. Time complexity should be O(1).

3. dequeue :
This function takes no input arguments and has return type T.
This should removes the first element which is entered and return that element as an answer.
Time complexity should be O(1).

4. front :
This function takes no input arguments and has return type T.
This should return the first element which is entered and return that element as an answer.
Time complexity should be O(1).

5. size :
Return the size of stack i.e. count of elements which are present ins stack right now.
Time complexity should be O(1).

6. isEmpty :
Checks if the queue is empty or not. Return true or false.
"""

Solution :

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class QueueUsingLL:

    def __init__(self):
        self.__head = None
        self.__tail = None
        self.__count = 0

    def enqueue(self, data):
        newNode = Node(data)
        if self.__head is None:
            self.__head = newNode
        else:
            self.__tail.next = newNode
        self.__tail = newNode
        self.__count = self.__count + 1

    def dequeue(self):
        if self.__head is None:
            return 0
        data = self.__head.data
        self.__head = self.__head.next
        self.__count = self.__count - 1
        return data

    def front(self):
        if self.__head is None:
            return 0
        data = self.__head.data

        return data

    def isEmpty(self):
        return self.getSize() == 0

    def getSize(self):
        return self.__count

q = QueueUsingLL()
li = [int(ele) for ele in input().split()]
i = 0
while i < len(li):
    choice = li[i]
    if choice == -1:
        break
    elif choice == 1:
        q.enqueue(li[i + 1])
        i += 1
    elif choice == 2:
        ans = q.dequeue()
        if ans != 0:
            print(ans)
        else:
            print(-1)
    elif choice == 3:
        ans = q.front()
        if ans != 0:
            print(ans)
        else:
            print(-1)
    elif choice == 4:
        print(q.getSize())
    elif choice == 5:
        if (q.isEmpty()):
            print('true')
        else:
            print('false')
    i += 1


#Stack Using 2 Queues
"""
You need to implement a Stack class using two queues as its data members.
Only 2 data members should be there inside the class - two queues, 
which should be created dynamically and both should be public. Use the inbuilt queue.

Implement the following public functions :

1. Constructor -
Initialises both the data members.

2. push :
This function should take one argument of type T and has return type void. 
This function should insert an element in the stack. Time complexity should be O(1).

3. pop :
This function takes no input arguments and has return type T. 
This should removes the last element which is entered and return that element as an answer.

4. top :
This function takes no input arguments and has return type T. 
This should return the last element which is entered and return that element as an answer.

5. getSize :
Return the size of stack i.e. count of elements which are present ins stack right now. 
Time complexity should be O(1).
"""

Solution :

import queue

class StackUsingQueues:

    def __init__(self):
        self.q1 = queue.Queue()
        self.q2 = queue.Queue()
        self.curr_size = 0

    def push(self, data):

        self.curr_size += 1
        self.q2.put(data)

        while (not self.q1.empty()):
            self.q2.put(self.q1.queue[0])
            self.q1.get()
        self.q = self.q1
        self.q1 = self.q2
        self.q2 = self.q

    def pop(self):

        if (self.q1.empty()):
            return
        x = self.q1.get()
        self.curr_size -= 1
        return x

    def top(self):
        if (self.q1.empty()):
            return -1
        return self.q1.queue[0]

    def getSize(self):
        return self.curr_size

s = StackUsingQueues()
li = [int(ele) for ele in input().split()]
i = 0
li1 = []
while i < len(li):
    choice = li[i]
    if choice == -1:
        break
    elif choice == 1:
        s.push(li[i + 1])
        i += 1
    elif choice == 2:
        ans = s.pop()
        if ans != 0:
            print(ans)
        else:
            print(-1)
    elif choice == 3:
        ans = s.top()
        if ans != 0:
            print(ans)
        else:
            print(-1)
    elif choice == 4:
        print(s.getSize())
    elif choice == 5:
        while s.q1.qsize() != 0:
            li1.append(s.q1.get())
        li1.reverse()
        print(*li1)

    i += 1


#Reverse Queue
"""
Given a queue of integers, reverse it without help of any explicit stack or queue. 
You need to change in the given queue itself.

Note : No need to return or print the queue.

Input format :
Line 1 : First Element - Size of Queue, Rest Elements - Elements Of Queue

Output format :
Queue elements
"""
Sample Input :
4 1 2 3 4     (1 is at front)
Sample Output :
4 3 2 1    (4 is at front)

Solution :

import queue

def reverseQueue(q1):
    Stack = []
    while (not q1.empty()):
        Stack.append(q1.queue[0])
        q1.get()
    while (len(Stack) != 0):
        q1.put(Stack[-1])
        Stack.pop()

from sys import setrecursionlimit
setrecursionlimit(11000)
li = [int(ele) for ele in (input().split()[1:])]
q1 = queue.Queue()
for ele in li:
    q1.put(ele)
reverseQueue(q1)
while (q1.empty() is False):
    print(q1.get(), end=' ')


#Reverse first K elements
"""
Given a queue and an integer k, reverse first k elements. Return the updated queue.
Do the problem in O(n) complexity.

Input Format :
Line 1 : Integer N, Size of Queue
Line 2 : Queue Elements (separated by space)
Line 3 : Integer k

Output Format:
Updated Queue elements
"""
Sample Input 1:
5
1 2 3 4 5
3
Sample Output 1:
3 2 1 4 5

Sample Input 2:
7
3 4 2 5 6 7 8
7
Sample Output 2:
8 7 6 5 2 4 3

Solution :

import queue

def reverseFirstK(q, k):
    if (q.empty() == True or k > q.qsize()):
        return
    if (k <= 0):
        return
    Stack = []
    for i in range(k):
        Stack.append(q.queue[0])
        q.get()
    while (len(Stack) != 0):
        q.put(Stack[-1])
        Stack.pop()
    for i in range(q.qsize() - k):
        q.put(q.queue[0])
        q.get()

from sys import setrecursionlimit
setrecursionlimit(11000)
n = int(input())
li = [int(ele) for ele in input().split()]
q = queue.Queue()
for ele in li:
    q.put(ele)
k = int(input())
reverseFirstK(q, k)
while (q.qsize() > 0):
    print(q.get())
    n -= 1



#Sum Of Nodes
"""
Given a binary tree, find and return the sum of all nodes.

Input format :
Elements in level order form (separated by space).
If any node does not have left or right child, take -1 in its place.
"""
Sample Input :
5 6 10 2 3 -1 -1 -1 -1 -1 9 -1 -1
Sample Output :
35

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def sumOfAllNodes(root):
    if (root == None):
        return 0
    return (root.data + sumOfAllNodes(root.left) + sumOfAllNodes(root.right))

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
print(sumOfAllNodes(root))


#Preorder Binary Tree
"""
Given a binary tree, print the preorder traversal of given tree.
Pre-order traversal is: Root LeftChild RightChild

Input format :
Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output Format :
Pre-order traversal, elements separated by space
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
Sample Output :
8 3 1 6 4 7 10 14 13

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def preOrder(root):
    if root:
        print(root.data,end=" ")
        preOrder(root.left)
        preOrder(root.right)

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
preOrder(root)


#Postorder Binary Tree
"""
Given a binary tree, print the postorder traversal of given tree.
Post-order traversal is: LeftChild RightChild Root

Input format :
Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output Format :
Post-order traversal, elements separated by space
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
Sample Output :
1 4 7 6 3 13 14 10 8

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def postOrder(root):
    if root:
        postOrder(root.left)
        postOrder(root.right)
        print(root.data, end=' ')

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
postOrder(root)


#Nodes Greater Than X
"""
Given a Binary Tree and an integer x, find and return the count of nodes which are having data greater than x.

Input format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Integer x

Output Format :
count
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
8
Sample Output :
3

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def countNodesGreaterThanX(root, x):
    if root==None:
        return 0
    count=0
    if root.data>x:
        count=count+1
    countLeft=countNodesGreaterThanX(root.left,x)
    countRight=countNodesGreaterThanX(root.right,x)
    return count + countLeft + countRight

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
x=int(input())
root = buildLevelTree(levelOrder)
print(countNodesGreaterThanX(root, x))


#Height Of Tree
"""
Given a binary tree, find and return the height of given tree.

Input format :
Nodes in the level order form (separated by space). If any node does not have left or right child, 
take -1 in its place

Output format :
Height
"""
Sample Input :
10
 9
4
-1
-1
 5
 8
-1
6
-1
-1
3
-1
-1
-1
Sample Output :
5

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def height(root):
    if root == None:
        return 0
    else:
        lDepth = height(root.left)
        rDepth = height(root.right)
        if (lDepth > rDepth):
            return lDepth + 1
        else:
            return rDepth + 1

def buildLevelTree():
    root = BinaryTreeNode(int(input()))
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = int(input())
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = int(input())
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

root = buildLevelTree()
print(height(root))


#Replace Node With Depth
"""
Given a a binary tree. Replace each of it's data with the depth of tree.
Root is at depth 0, change its value to 0 and next level nodes are at depth 1 and so on.
Print the tree after modifying in inorder fashion.

Input format :
Line 1 :  Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output Format :
Inorder traversal of modified tree.
"""
Sample Input :
     1 2 3 4 5 6 7 -1 -1 -1 -1 -1 -1 -1 -1
Sample Output :
     2
     1
     2
     0
     2
     1
     2

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def replaceWithDepth(root, level=0):
    if root == None:
        return
    root.data = level
    replaceWithDepth(root.left, level + 1)
    replaceWithDepth(root.right, level + 1)

def inorder(root):
    if root is None:
        return
    inorder(root.left)
    print(root.data)
    inorder(root.right)

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
replaceWithDepth(root)
inorder(root)


#Is node present?
"""
Given a Binary Tree and an integer x, check if node with data x is present in the input binary tree or not. 
Return true or false.

Input format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Integer x

Output Format :
true or false
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
7
Sample Output :
true

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def isNodePresent(root, x):
    if (root == None):
        return False
    if (root.data == x):
        return True
    res1 = isNodePresent(root.left, x)
    if res1:
        return True
    res2 = isNodePresent(root.right, x)
    return res2

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
x=int(input())
present=isNodePresent(root, x)
if present:
    print('true')
else:
    print('false')


#Nodes without sibling
"""
Given a binary tree, print all nodes that don’t have a sibling.

Edit : Print the elements in different lines. And order of elements doesn't matter.

Input format :
Elements in level order form (separated by space). If any node does not have left or right child, 
take -1 in its place.

Output format :
Print nodes separated by new line.
"""
Sample Input :
5 6 10 2 3 -1 -1 -1 -1 -1 9 -1 -1
Sample Output :
9

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def nodesWithoutSibling(root):
    if root == None:
        return
    if root.left is not None and root.right is not None:
        nodesWithoutSibling(root.left)
        nodesWithoutSibling(root.right)

    elif root.right is not None:
        print(root.right.data)
        nodesWithoutSibling(root.right)

    elif root.left is not None:
        print(root.left.data)
        nodesWithoutSibling(root.left)

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
nodesWithoutSibling(root)




#Mirror Binary Tree
"""
Mirror the given binary tree. That is,
right child of every nodes should become left and left should become right.

Note : You don't need to print or return the tree, just mirror it.

Input format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output format : Elements in level order form (Every level in new line)
"""
Sample Input 1:
1 2 3 4 5 6 7 -1 -1 -1 -1 -1 -1 -1 -1
Sample Output 1:
1
3 2
7 6 5 4
Sample Input 2:
5 10 6 2 3 -1 -1 -1 -1 -1 9 -1 -1
Sample Output 2:
5
6 10
3 2
9

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def mirrorBinaryTree(root):
    if root==None:
        return None
    else:
        temp = root
        mirrorBinaryTree(root.left)
        mirrorBinaryTree(root.right)
        temp = root.left
        root.left = root.right
        root.right = temp

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

def printLevelATNewLine(root):

    if root==None:
        return
    inputQ = queue.Queue()
    outputQ = queue.Queue()
    inputQ.put(root)
    while not inputQ.empty():
        while not inputQ.empty():
            curr = inputQ.get()
            print(curr.data, end=' ')
            if curr.left!=None:
                outputQ.put(curr.left)
            if curr.right!=None:
                outputQ.put(curr.right)
        print()
        inputQ, outputQ = outputQ, inputQ

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
mirrorBinaryTree(root)
printLevelATNewLine(root)


#Diameter Of Binary Tree
"""
Given a Binary Tree, find and return the diameter of input binary tree.
Diameter is - largest count of nodes between any two leaf nodes in the binary tree 
(both the leaf nodes are inclusive).

Input format :
Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output Format :
diameter
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
Sample Output :
7

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def height(root):
    if root is None:
        return 0
    return 1 + max(height(root.left), height(root.right))

def diameter(root):
    if root is None:
        return 0
    lheight = height(root.left)
    rheight = height(root.right)

    ldiameter = diameter(root.left)
    rdiameter = diameter(root.right)

    return max(lheight + rheight + 1, max(ldiameter, rdiameter))

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
print(diameter(root))


#Print Levelwise
"""
Given a binary tree, print the tree in level wise order.
For printing a node with data N, you need to follow the exact format -
        N:L:x,R:y
wherer, N is data of any node present in the binary tree. 
x and y are the values of left and right child of node N. Print -1. if any child is null.
There is no space in between.
You need to print all nodes in the level order form in different lines.

Input format :
Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
Sample Output :
8:L:3,R:10
3:L:1,R:6
10:L:-1,R:14
1:L:-1,R:-1
6:L:4,R:7
14:L:13,R:-1
4:L:-1,R:-1
7:L:-1,R:-1
13:L:-1,R:-1

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def printLevelWise(root):
    if root==None:
        return
    q = queue.Queue()

    q.put(root)
    while not q.empty():
        curr = q.get()
        print(curr.data, end=':')
        if curr.left!=None:
            print("L",end=":")
            print(curr.left.data,end=",")
            q.put(curr.left)
        else:
            print('L:-1,',end='')
        if curr.right!=None:
            print("R",end=":")
            print(curr.right.data,end="")
            q.put(curr.right)
        else:
            print('R:-1',end='')
        print()

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
printLevelWise(root)


#Construct Tree Using Inorder and Preorder
"""
Given Preorder and Inorder traversal of a binary tree, 
create the binary tree associated with the traversals.You just need to construct the tree and return the root.

Note: Assume binary tree contains only unique elements.

Input format :
Line 1 : n (Total number of nodes in binary tree)
Line 2 : Pre order traversal
Line 3 : Inorder Traversal

Output Format :
Elements are printed level wise, each level in new line (separated by space).
"""
Sample Input :
12
1 2 3 4 15 5 6 7 8 10 9 12
4 15 3 2 5 1 6 10 8 7 9 12
Sample Output :
1
2 6
3 5 7
4 8 9
15 10 12

Solution :

import queue

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def buildTreePreOrder(preorder, inorder,inStrt, inEnd):
    if (inStrt > inEnd):
        return None
    tNode = Node(preorder[buildTreePreOrder.preIndex])
    buildTreePreOrder.preIndex += 1
    if inStrt == inEnd :
        return tNode
    inIndex = search(inorder, inStrt, inEnd, tNode.data)
    tNode.left = buildTreePreOrder(preorder, inorder, inStrt, inIndex-1)
    tNode.right = buildTreePreOrder(preorder, inorder, inIndex + 1, inEnd)
    return tNode

def search(arr, start, end, value):
    for i in range(start, end + 1):
        if arr[i] == value:
            return i

def printLevelATNewLine(root):

    if root==None:
        return
    inputQ = queue.Queue()
    outputQ = queue.Queue()
    inputQ.put(root)
    while not inputQ.empty():
        while not inputQ.empty():
            curr = inputQ.get()
            print(curr.data, end=' ')
            if curr.left!=None:
                outputQ.put(curr.left)
            if curr.right!=None:
                outputQ.put(curr.right)
        print()
        inputQ, outputQ = outputQ, inputQ

n=int(input())
preorder = [int(i) for i in input().strip().split()]
inorder = [int(i) for i in input().strip().split()]
buildTreePreOrder.preIndex = 0
root = buildTreePreOrder(preorder, inorder,0, len(inorder)-1)
printLevelATNewLine(root)


#Construct Tree Using Inorder and PostOrder
"""
Given Postorder and Inorder traversal of a binary tree, create the binary tree associated with the traversals.
You just need to construct the tree and return the root.

Note: Assume binary tree contains only unique elements.

Input format :
Line 1 : n (Total number of nodes in binary tree)
Line 2 : Post order traversal
Line 3 : Inorder Traversal

Output Format :
Elements are printed level wise, each level in new line (separated by space).
"""
Sample Input :
8
8 4 5 2 6 7 3 1
4 8 2 5 1 6 3 7
Sample Output :
1
2 3
4 5 6 7
8

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def buildTreePostOrder(postorder, inorder):
    if(len(postorder)==0):
        return
    rootData=postorder[-1]
    root=BinaryTreeNode(rootData)
    for i in range(len(inorder)):
        if(inorder[i]==rootData):
            break
    lp=len(postorder)
    leftTree=buildTreePostOrder(postorder[:i],inorder[:i])
    rightTree=buildTreePostOrder(postorder[i:-1],inorder[i+1:])
    root.left=leftTree
    root.right=rightTree
    return root

def printLevelATNewLine(root):

    if root==None:
        return
    inputQ = queue.Queue()
    outputQ = queue.Queue()
    inputQ.put(root)
    while not inputQ.empty():
        while not inputQ.empty():
            curr = inputQ.get()
            print(curr.data, end=' ')
            if curr.left!=None:
                outputQ.put(curr.left)
            if curr.right!=None:
                outputQ.put(curr.right)
        print()
        inputQ, outputQ = outputQ, inputQ

n=int(input())
postOrder = [int(i) for i in input().strip().split()]
inorder = [int(i) for i in input().strip().split()]
root = buildTreePostOrder(postOrder, inorder)
printLevelATNewLine(root)


#Create & Insert Duplicate Node
"""
Given a Binary Tree with N number of nodes, for each node create a new duplicate node, 
and insert that duplicate as left child of the original node.

Note : Root will remain same. 
So you just need to insert nodes in the given Binary Tree and no need to print or return anything.

Input format :
Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output Format :
Level order traversal of updated tree. (Every level in new line)
"""
Sample Input :
8 5 10 2 6 -1 -1 -1 -1 -1 7 -1 -1
Sample Output :
8
8 10
5 10
5 6
2 6 7
2 7

Solution :

import queue

class Node:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def NewNode(obj):
    new = Node(root)
    new.data = obj
    new.left = None
    new.right = None
    return new

def insertDuplicateNode(root):
    if root == None:
        return
    temp = Node(root)
    insertDuplicateNode(root.left)
    insertDuplicateNode(root.right)
    temp = root.left
    root.left = NewNode(root.data)
    root.left.left = temp
    pass

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = Node(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = Node(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = Node(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

def printLevelATNewLine(root):

    if root == None:
        return
    inputQ = queue.Queue()
    outputQ = queue.Queue()
    inputQ.put(root)
    while not inputQ.empty():
        while not inputQ.empty():
            curr = inputQ.get()
            print(curr.data, end=' ')
            if curr.left != None:
                outputQ.put(curr.left)
            if curr.right != None:
                outputQ.put(curr.right)
        print()
        inputQ, outputQ = outputQ, inputQ

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
insertDuplicateNode(root)
printLevelATNewLine(root)


#Min and max
"""
Given a binary tree, find and return the min and max data value of given binary tree.
Return the output as an object of PairAns class, which is already created.

Input format :
Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)

Output Format :
Max and min (separated by space)
"""
Sample Input :
8 3 10 1 6 -1 14 -1 -1 4 7 13 -1 -1 -1 -1 -1 -1 -1
Sample Output :
14 1

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

INT_MIN = -2147483648
INT_MAX = 2147483647

def minMax(root):
    if root == None:
        return 2147483647, -2147483648

    leftmin, leftmax = minMax(root.left)
    rightmin, rightmax = minMax(root.right)
    minimum = min(leftmin, rightmin, root.data)
    maximum = max(leftmax, rightmax, root.data)

    return minimum, maximum

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
minimum, maximum = minMax(root)
print(maximum, minimum)


#Level order traversal
"""
Given a binary tree, print the level order traversal. Make sure each level start in new line.

Input format :
Elements in level order form (separated by space). If any node does not have left or right child, take -1 in its place.

Output Format :
Elements are printed level wise, each level in new line (separated by space).
"""
Sample Input :
5 6 10 2 3 -1 -1 -1 -1 -1 9 -1 -1
Sample Output :
5
6 10
2 3
9

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def printLevelATNewLine(root):
    if root is None:
        return
    q = []
    q.append(root)
    while q:
        count = len(q)
        while count > 0:
            temp = q.pop(0)
            print(temp.data, end = ' ')
            if temp.left:
                q.append(temp.left)
            if temp.right:
                q.append(temp.right)
            count -= 1
        print('')

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
printLevelATNewLine(root)


#Path Sum Root to Leaf
"""
Given a binary tree and a number k, 
print out all root to leaf paths where the sum of all nodes value is same as the given number k.

Input format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : k

Output format : Print each path in new line, elements separated by space
"""
Sample Input 1 :
5 6 7 2 3 -1 1 -1 -1 -1 9 -1 -1 -1 -1
13
Sample Output 1 :
5 6 2
5 7 1

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def rootToLeafPathsSumToK(root, k, lst):
    if root == None:
        return None
    if root.left == None and root.right == None and root.data == k:
        print(*lst, root.data)
        return
    lst.append(root.data)
    rootToLeafPathsSumToK(root.left, k - root.data, lst)
    rootToLeafPathsSumToK(root.right, k - root.data, lst)
    lst.pop()
    return

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
k = int(input())
rootToLeafPathsSumToK(root, k, [])


#Print nodes at distance k from node
"""
Given a binary tree, a node and an integer K, print nodes which are at K distance from the the given node.

Input format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Node
Line 3 : K

Output format : Answer nodes in different line
"""
Sample Input :
5 6 10 2 3 -1 -1 -1 -1 -1 9 -1 -1
3
1
Sample Output :
9
6

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def printk(root, k):
    if root is None or k < 0:
        return
    if k == 0:
        print(root.data)
        return
    printk(root.left, k - 1)
    printk(root.right, k - 1)

def printknode(root, n, k):
    if root is None:
        return -1
    if root.data == n:
        printk(root, k)
        return 0

    ld = printknode(root.left, n, k)
    if ld != -1:
        if ld + 1 == k:
            print(root.data)
        else:
            printk(root.right, k - ld - 2)
        return ld + 1

    rd = printknode(root.right, n, k)
    if rd != -1:
        if rd + 1 == k:
            print(root.data)
        else:
            printk(root.left, k - rd - 2)
        return rd + 1

    return -1

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
n = int(input())
k = int(input())
ans = printknode(root, n, k)




#Search In BST
"""
Given a BST and an integer k. Find if the integer k is present in given BST or not.
Return the node with data k if it is present, return null otherwise.
Assume that BST contains all unique elements.

Input Format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Integer k

Output Format :
Node with data k
"""
Sample Input 1 :
8 5 10 2 6 -1 -1 -1 -1 -1 7 -1 -1
2
Sample Output 1 :
2
Sample Input 2 :
8 5 10 2 6 -1 -1 -1 -1 -1 7 -1 -1
12
Sample Output 2 :
(empty)

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def searchInBST(root, k):
    if root==None:
        return False
    if root.data==k:
        return root.data
    elif root.data>k:
        return searchInBST(root.left,k)
    elif root.data<k:
        return searchInBST(root.right,k)
    else:
        return False

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length<=0 or levelorder[0]==-1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left =leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right =rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
k=int(input())
node=searchInBST(root, k)
if node:
    print(node)


#Elements Between K1 and K2
"""
Given a Binary Search Tree and two integers k1 and k2, 
find and print the elements which are in range k1 and k2 (both inclusive).
Print the elements in increasing order.

Input format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Two Integers k1 and k2

Output Format :
Required elements (separated by space)
"""
Sample Input :
8 5 10 2 6 -1 -1 -1 -1 -1 7 -1 -1
6 10
Sample Output :
6 7 8 10

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def elementsInRangeK1K2(root, k1, k2):
    if root == None:
        return
    if k1 < root.data:
        elementsInRangeK1K2(root.left, k1, k2)
    if k1 <= root.data and k2 >= root.data:
        print(root.data, end=" ")
    if k2 > root.data:
        elementsInRangeK1K2(root.right, k1, k2)

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
k1, k2 = (int(i) for i in input().strip().split())
elementsInRangeK1K2(root, k1, k2)


#Construct BST
"""
Given a sorted integer array A of size n which contains all unique elements. 
You need to construct a balanced BST from this input array. Return the root of constructed BST.

Note : If array size is even, take first mid as root.

Input format :
Line 1 : Integer n (Size of array)
Line 2 : Array elements (separated by space)

Output Format :
BST elements (in pre order traversal, separated by space)
"""
Sample Input :
7
1 2 3 4 5 6 7
Sample Output :
4 2 1 3 6 5 7

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def constructBST(lst):
    if not lst:
        return None
    if len(lst) % 2 != 0:
        mid = (len(lst)) // 2
        root = BinaryTreeNode(lst[mid])
        root.left = constructBST(lst[:mid])
        root.right = constructBST(lst[mid + 1:])

    else:
        mid = ((len(lst)) // 2) - 1
        root = BinaryTreeNode(lst[mid])
        root.left = constructBST(lst[:mid])
        root.right = constructBST(lst[mid + 1:])

    return root

def preOrder(root):

    if root == None:
        return
    print(root.data, end=' ')
    preOrder(root.left)
    preOrder(root.right)

n = int(input())
lst = [int(i) for i in input().strip().split()]
root = constructBST(lst)
preOrder(root)




#Find path in BST
"""
Given a BST and an integer k. Find and return the path from the node with data k and root
(if a node with data k is present in given BST). Return null otherwise.
Assume that BST contains all unique elements.

Input Format :
Line 1 : Elements in level order form (separated by space)
(If any node does not have left or right child, take -1 in its place)
Line 2 : Integer k

Output Format :
Path from node k to root
"""
Sample Input :
8 5 10 2 6 -1 -1 -1 -1 -1 7 -1 -1
2
Sample Output :
2
5
8

Solution :

import queue

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

def findPathBST(root, data):
    # Implement the function here
    if root is None:
        return None
    if root.data == data:
        l = list()
        l.append(data)
        return l

    leftOutput = findPathBST(root.left, data)
    if leftOutput != None:
        leftOutput.append(root.data)
        return leftOutput

    rightOutput = findPathBST(root.right, data)
    if rightOutput != None:
        rightOutput.append(root.data)
        return rightOutput

    else:
        return None

def buildLevelTree(levelorder):
    index = 0
    length = len(levelorder)
    if length <= 0 or levelorder[0] == -1:
        return None
    root = BinaryTreeNode(levelorder[index])
    index += 1
    q = queue.Queue()
    q.put(root)
    while not q.empty():
        currentNode = q.get()
        leftChild = levelorder[index]
        index += 1
        if leftChild != -1:
            leftNode = BinaryTreeNode(leftChild)
            currentNode.left = leftNode
            q.put(leftNode)
        rightChild = levelorder[index]
        index += 1
        if rightChild != -1:
            rightNode = BinaryTreeNode(rightChild)
            currentNode.right = rightNode
            q.put(rightNode)
    return root

levelOrder = [int(i) for i in input().strip().split()]
root = buildLevelTree(levelOrder)
data = int(input())
path = findPathBST(root, data)
if path is not None:
    for ele in path:
        print(ele)


#BST Class
"""
Implement the BST class which includes following functions -

1. search
Given an element, find if that is present in BSt or not. Return true or false.

2. insert -
Given an element, insert that element in the BST at the correct position. Assume unique elements will be given.

3. delete -
Given an element, remove that element from the BST. 
If the element which is to be deleted has both children, 
replace that with the minimum element from right sub-tree.

4. printTree (recursive) -
Print the BST in ithe following format -
For printing a node with data N, you need to follow the exact format -
                N:L:x,R:y
                
wherer, N is data of any node present in the binary tree. x and y are the values of left and right child of node N. 
Print the children only if it is not null.

There is no space in between.

You need to print all nodes in the recursive format in different lines.

Note : main function is given for your reference which we are using internally to test the class.
"""

Solution :

class BinaryTreeNode:
    def __init__(self, data):
        self.data = data
        self.left = None
        self.right = None

class BST:

    def __init__(self):
        self.root = None
        self.numNodes = 0

    def printTreeHelper(self, root):
        if root == None:
            return
        print(root.data, end=":")
        if root.left != None:
            print("L:", end='')
            print(root.left.data, end=',')
        if root.right != None:
            print("R:", end='')
            print(root.right.data, end='')
        print()
        self.printTreeHelper(root.left)
        self.printTreeHelper(root.right)

    def printTree(self):
        self.printTreeHelper(self.root)

    def PresentHelper(self, root, data):
        if root == None:
            return False
        if root.data == data:
            return True
        if root.data > data:
            return self.PresentHelper(root.left, data)
        else:
            return self.PresentHelper(root.right, data)

    def search(self, data):
        return self.PresentHelper(self.root, data)

    def insertHelper(self, root, data):
        if root == None:
            node = BinaryTreeNode(data)
            return node
        if root.data > data:
            root.left = self.insertHelper(root.left, data)
        else:
            root.right = self.insertHelper(root.right, data)
        return root

    def insert(self, data):
        self.numNodes += 1
        self.root = self.insertHelper(self.root, data)

    # Implement this function here
    def min(self, root):
        if root == None:
            return 10000
        if root.left == None:
            return root.data
        return self.min(root.left)

    def deletedatahelper(self, root, data):
        if root == None:
            return False, None
        if root.data < data:
            deleted, newRightNode = self.deletedatahelper(root.right, data)
            root.right = newRightNode
            return deleted, root
        if root.data > data:
            deleted, newLeftNode = self.deletedatahelper(root.left, data)
            root.left = newLeftNode
            return deleted, root
        if root.left == None and root.right == None:
            return True, None
        if root.left == None:
            return True, root.right
        if root.right == None:
            return True, root.left
        replacement = self.min(root.right)
        root.data = replacement
        deleted, newRightNode = self.deletedatahelper(root.right, replacement)
        root.right = newRightNode
        return True, root

    def delete(self, data):
        deleted, newRoot = self.deletedatahelper(self.root, data)
        if deleted:
            self.numNodes -= 1
        self.root = newRoot
        return deleted

    def count(self):
        return self.numNodes

b = BST()
li = [int(ele) for ele in input().split()]
i = 0
while (i < (len(li))):
    choice = li[i]
    if choice == 1:
        data = li[i + 1]
        b.insert(data)
        i += 2
    elif choice == 2:
        data = li[i + 1]
        b.delete(data)
        i += 2
    elif choice == 3:
        data = li[i + 1]
        ans = b.search(data)
        if ans is True:
            print('true')
        else:
            print('false')
        i += 2
    else:
        b.printTree()
        i += 1



#Sum of all nodes
"""
Given a generic tree, count and return the sum of all nodes present in the given tree.

Input format :
Elements in level order form separated by space (as per done in class). Order is -
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element

Output Format :
Sum of all nodes
"""
Sample Input :
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output :
190

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

    def __str__(self):
        return str(self.data)

def sumofNodes(tree):
    sum = tree.data
    for child in tree.children:
        sum += sumofNodes(child)
    return sum

    pass

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
print(sumofNodes(tree))


#Node With Largest Data
"""
Given a generic tree, find and return the node with maximum data. 
You need to return the complete node which is having maximum data.
Return null if tree is empty.

Input format :
Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output Format :
Node with largest data
"""
Sample Input :
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output :
50

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

    def __str__(self):
        return str(self.data)

def maxDataNode(tree):
    if tree == []:
        return None
    largest = tree.data
    for child in tree.children:
        if child.data > largest:
            largest = child.data
        MaxChild = maxDataNode(child)
        if MaxChild > largest:
            largest = MaxChild
    return largest

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
print(maxDataNode(tree))


#Height Of Tree
"""
Given a generic tree, find and return the height of given tree.

Input format :
Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output Format :
Height
"""
Sample Input :
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output :
3

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

    def __str__(self):
        return str(self.data)

def height(tree):
    if tree == []:
        return 0
    maxHeight = 0
    for child in tree.children:
        depth = height(child)
        if maxHeight < depth:
            maxHeight = depth
    return maxHeight + 1

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
print(height(tree))


#Print Levelwise
"""
Given a generic tree, print the input tree in level wise order. ####For printing a node with data N, 
you need to follow the exact format -

                N:x1,x2,x3,...,xn

wherer, N is data of any node present in the binary tree. x1, x2, x3, ...., xn are the children of node N
There is no space in between.
You need to print all nodes in the level order form in different lines.

Input format :
Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output Format :
Level wise print
"""
Sample Input :
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output :
10:20,30,40
20:40,50
30:
40:
40:
50:


Solution :

import queue

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []
    def __str__(self):
        return str(self.data)

def printLevelWiseTree(tree):
    if tree==None:
        return
    q=queue.Queue()
    q.put(tree)
    while(not(q.empty())):
        temp=q.get()
        print(temp.data,end=":")
        for child in temp.children:
            q.put(child)
            if child==temp.children[len(temp.children)-1]:
                print(child,end="")
            else:
                print(child,end=",")
        print()
    return

    pass

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i<size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0,childCount):
            temp = treeNode(int(arr[i+j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
printLevelWiseTree(tree)


#Contains x
"""
Given a generic tree and an integer x, check if x is present in the given tree or not. 
Return true if x is present, return false otherwise.

Input format :
Line 1 : Integer x
Line 2 : Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output format :
true or false
"""
Sample Input 1 :
40
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 1 :
true
Sample Input 2 :
4
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 2:
false

Solution :

class treeNode:

    def __init__(self, data):
        self.data = data
        self.children = []

    def __str__(self):
        return str(self.data)

def containX(tree, x):
    if not tree:
        return False

    if tree.data == x:
        return True

    for child in tree.children:
        if containX(child, x):
            return True

    return False

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1

    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1

        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)

        i += childCount

    return root

x = int(input())
arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
if containX(tree, x):
    print('true')
else:
    print('false')


#Count leaf Nodes
"""
Given a generic tree, count and return the number of leaf nodes present in the given tree.

Input format :
Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output Format :
Count of leaf nodes
"""
Sample Input 1 :
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 1 :
4

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []
    def __str__(self):
        return str(self.data)

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    count=0
    while i<size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        if childCount==0:
            count+=1

        for j in range(0,childCount):
            temp = treeNode(int(arr[i+j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root,count

arr = list(int(x) for x in input().strip().split(' '))
tree,count = createLevelWiseTree(arr)
print(count)


#Node with maximum child sum
"""
Given a tree, find and return the node for which sum of data of all children and the node itself is maximum. 
In the sum, data of node itself and data of immediate children is to be taken.

Input format :
Line 1 : Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output format :
Node with maximum sum.
"""
Sample Input :
5 3 1 2 3 1 15 2 4 5 1 6 0 0 0 0
Sample Output :
1

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

def maxSumUtil(root, resNode, maxsum):
    if root == None:
        return
    currsum = root.data
    count = len(root.children)
    for i in range(0, count):
        currsum += root.children[i].data
        resNode, maxsum = maxSumUtil(root.children[i], resNode, maxsum)
    if currsum > maxsum:
        resNode = root
        maxsum = currsum
    return resNode, maxsum

def maxSum(root):
    resNode, maxsum = treeNode(None), 0
    resNode, maxsum = maxSumUtil(root, resNode, maxsum)
    return resNode.data

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

arr = list(int(x) for x in input().strip().split(' '))
root = createLevelWiseTree(arr)
print(maxSum(root))


#Structurally identical
"""
Given two Generic trees, return true if they are structurally identical 
i.e. they are made of nodes with the same values arranged in the same way.

Input format :
Line 1 : Tree 1 elements in level order form separated by space (as per done in class). 

Order is - 
            Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 
Line 2 : Tree 2 elements in level order form separated by space (as per done in class). 

Order is - 
            Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output format :
true or false
"""
Sample Input 1 :
10 3 20 30 40 2 40 50 0 0 0 0
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 1 :
true
Sample Input 2 :
10 3 20 30 40 2 40 50 0 0 0 0
10 3 2 30 40 2 40 50 0 0 0 0
Sample Output 2:
false

Solution :

class treeNode:

    def __init__(self, data):
        self.data = data
        self.children = []

def isIdentical(tree1, tree2):
    if not tree1:
        if not tree2:
            return True
        return False

    if (tree1.data != tree2.data) or len(tree1.children) != len(tree2.children):
        return False

    for child1, child2 in zip(tree1.children, tree2.children):
        if not isIdentical(child1, child2):
            return False

    return True

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1

    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1

        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)

        i += childCount

    return root

arr1 = list(int(x) for x in input().strip().split(' '))
tree1 = createLevelWiseTree(arr1)
arr2 = list(int(x) for x in input().strip().split(' '))
tree2 = createLevelWiseTree(arr2)
if isIdentical(tree1, tree2):
    print('true')
else:
    print('false')


#Next larger
"""
Given a generic tree and an integer n. Find and return the node with next larger element in the Tree 
i.e. find a node with value just greater than n.
Return NULL if no node is present with the value greater than n.

Input Format :
Line 1 : Integer n
Line 2 : Elements in level order form separated by space (as per done in class). Order is - 
Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 

Output Format :
Node with value just greater than n.
"""
Sample Input 1 :
18
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 1 :
20
Sample Input 2 :
21
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 2:
30

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

def nextLargest(tree, n):
    if tree==[]:
        return
    Max=2147483647
    for child in tree.children:
        if child.data>n and child.data<Max:
            Max=child.data
        r=nextLargest(child,n)
        if r>n and r<Max:
            Max=r
    return Max

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i<size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0,childCount):
            temp = treeNode(int(arr[i+j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

n = int(input())
arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
print(nextLargest(tree, n))


#Replace with depth
"""
In a given Generic Tree, replace each node with its depth value. 
You need to just update the data of each node, no need to return or print anything.

Input format :
Line 1 : Elements in level order form separated by space (as per done in class). 
Order is - 
            Root_data, n (No_Of_Child_Of_Root), n children, and so on for every element 
"""
Sample Input 1 :
10 3 20 30 40 2 40 50 0 0 0 0
Sample Output 1 : (Level wise, each level in new line)
0
1 1 1
2 2

Solution :

class treeNode:
    def __init__(self, data):
        self.data = data
        self.children = []

def replacewithDepth(tree, depth):

    if tree is None:
        return
    tree.data = depth
    for child in tree.children:
        replacewithDepth(child, depth + 1)
    return tree

def createLevelWiseTree(arr):
    root = treeNode(int(arr[0]))
    q = [root]
    size = len(arr)
    i = 1
    while i < size:
        parent = q.pop(0)
        childCount = int(arr[i])
        i += 1
        for j in range(0, childCount):
            temp = treeNode(int(arr[i + j]))
            parent.children.append(temp)
            q.append(temp)
        i += childCount
    return root

def printLevelAtNewLine(tree):
    q = [tree]
    newq = []
    while q:
        parent = q.pop(0)
        print(parent.data, end=' ')
        for child in parent.children:
            newq.append(child)
        if len(q) == 0:
            q = newq
            newq = []
            print()  # Move to next Line

arr = list(int(x) for x in input().strip().split(' '))
tree = createLevelWiseTree(arr)
replacewithDepth(tree, 0)
printLevelAtNewLine(tree)




#Maximum Frequency
"""
You are given an array of integers that contain numbers in random order.
Write a program to find and return the number which occurs the maximum times in the given input.
If two or more elements contend for the maximum frequency, return the element which occurs in the array first.

Input Format :
Line 1 : An Integer N i.e. size of array
Line 2 : N integers which are elements of the array, separated by spaces

Output Format :
Most frequent element
"""
Sample Input 1 :
13
2 12 2 11 12 2 1 2 2 11 12 2 6
Sample Output 1 :
2
Sample Input 2 :
3
1 4 5
Sample Output 2 :
1

Solution :

def maxFreq(l):
    dict = {}
    count, itm = 0, ''
    for item in reversed(l):
        dict[item] = dict.get(item, 0) + 1
        if dict[item] >= count :
            count, itm = dict[item], item
    return(itm)

n=int(input())
l=list(int(i) for i in input().strip().split(' '))
print(maxFreq(l))


#Pair Sum To 0
"""
Given a random integer array A of size N. Find and print the pair of elements in the array which sum to 0.
Array A can contain duplicate elements.
While printing a pair, print the smaller element first.
That is, if a valid pair is (6, -6) print "-6 6". 
There is no constraint that out of 5 pairs which have to be printed in 1st line. 
You can print pairs in any order, just be careful about the order of elements in a pair.

Input format :
Line 1 : Integer N (Array size)
Line 2 : Array elements (separated by space)

Output format :
Line 1 : Pair 1 elements (separated by space)
Line 2 : Pair 2 elements (separated by space)
Line 3 : and so on
"""
Sample Input:
5
2 1 -2 2 3
Sample Output :
-2 2
-2 2

Solution :

def pairSum0(l):
    dic={}
    k=0
    for num in l:
        if k-num in dic:
            for i in range(dic[k-num]):
                if k-num<num:
                    print(k-num,num)
                else:
                    print(num,k-num)
        if num in dic:
            dic[num]+=1
        else:
            dic[num]=1

n=int(input())
l=list(int(i) for i in input().strip().split(' '))
pairSum0(l)


#Extract Unique characters
"""
Given a string, you need to remove all the duplicates. 
That means, the output string should contain each character only once. 
The respective order of characters should remain same.

Input format :
String S

Output format :
Output String
"""
Sample Input 1 :
ababacd
Sample Output 1 :
abcd
Sample Input 2 :
abcde
Sample Output 2 :
abcde

Solution :

from collections import OrderedDict

def removeDupWithOrder(str):
    return "".join(OrderedDict.fromkeys(str))

if __name__ == "__main__":
    str = input()
    print(removeDupWithOrder(str))


#Longest consecutive Sequence
"""
You are given with an array of integers that contain numbers in random order. 
Write a program to find the longest possible sequence of consecutive numbers using the numbers from given array.
You need to return the output array which contains consecutive elements. 
Order of elements in the output is not important.
Best solution takes O(n) time.
If two sequences are of equal length then, 
return the sequence starting with the number whose occurrence is earlier in the array.

Input Format :
Line 1 : Integer n, Size of array
Line 2 : Array elements (separated by space)
"""
Sample Input 1 :
13
2 12 9 16 10 5 3 20 25 11 1 8 6
Sample Output 1 :
8
9
10
11
12
Sample Input 2 :
7
3 7 2 1 9 8 1
Sample Output 2 :
7
8
9
Explanation: Sequence should be of consecutive numbers. Here we have 2 sequences with same length i.e. [1, 2, 3] and [7, 8, 9], but output should be [7, 8, 9] because the starting point of [7, 8, 9] comes first in input array.
Sample Input 3 :
7
15 24 23 12 19 11 16
Sample Output 3 :
15
16

Solution :

def longestConsecutiveSubsequence(l):
    m = {l[i]:i for i in range(len(l)-1,-1,-1)}
    visited = {}
    start,end = l[0],l[0]
    startM,endM = start,end
    for num in l:
        if num not in visited:
            visited[num] = True
            start,end = num,num
            while start-1 in m:
                start-=1
                visited[start] = True
            while end+1 in m:
                end+=1
                visited[end] = True
            if (endM-startM+1<end-start+1) or ((endM-startM+1 == end-start+1) and (m[start]<m[startM])):
                startM,endM = start,end
    return startM,endM

n=int(input())
l=list(int(i) for i in input().strip().split(' '))
start,end = longestConsecutiveSubsequence(l)
for num in range(start,end+1):
    print(num)


#Pairs with difference K
"""
You are given with an array of integers and an integer K. 
Write a program to find and print all pairs which have difference K.
Take difference as absolute.

Input Format :
Line 1 : Integer n, Size of array
Line 2 : Array elements (separated by space)
Line 3 : K

Output format :
Print pairs in different lines (pair elements separated by space). In a pair, smaller element should be printed first.
(Order of different pairs is not important)
"""
Sample Input 1 :
4
5 1 2 4
3
Sample Output 1 :
2 5
1 4
Sample Input 2 :
4
4 4 4 4
0
Sample Output 2 :
4 4
4 4
4 4
4 4
4 4
4 4

Solution :

def printSeq(li, k, d):
    if k != 0:
        for ele in li:
            search1 = ele - k
            search2 = k + ele
            if search1 in d:
                for i in range(d[search1] * d[ele]):
                    if search1 < ele:
                        print(search1, ele)
                    else:
                        print(ele, search1)

            if search2 in d:
                for i in range(d[search2] * d[ele]):
                    if search2 > ele:
                        print(ele, search2)
                    else:
                        print(search2, ele)
            d[ele] = 0

    else:
        for i in range(len(li)):
            for j in range(i + 1, len(li)):
                if abs(li[i] - li[j]) == k:
                    if li[i] > li[j]:
                        print(li[j], li[i])
                    else:
                        print(li[i], li[j])

n = int(input())
li = [int(ele) for ele in input().split()]
k = int(input())
d = {}
for ele in li:
    d[ele] = d.get(ele, 0) + 1
printSeq(li, k, d)


#Longest subset zero sum
"""
Given an array consisting of positive and negative integers, 
find the length of the longest subarray whose sum is zero.

NOTE: You have to return the length of longest subarray .

Input Format :
Line 1 : Contains an integer N i.e. size of array
Line 2 : Contains N elements of the array, separated by spaces

Output Format
Line 1 : Length of longest subarray 
"""
Sample Input :
10
 95 -97 -387 -435 -5 -70 897 127 23 284
Sample Output :
5

Solution :

def maxLen(arr):
    hash_map = {}
    max_len = 0
    curr_sum = 0

    for i in range(len(arr)):
        curr_sum += arr[i]
        if arr[i] is 0 and max_len is 0:
            max_len = 1

        if curr_sum is 0:
            max_len = i + 1

        if curr_sum in hash_map:
            max_len = max(max_len, i - hash_map[curr_sum])
        else:

            hash_map[curr_sum] = i

    return max_len

n = int(input())
arr = list(int(i) for i in input().strip().split(' '))
print(maxLen(arr))



#Code : Remove Min
"""
Implement the function RemoveMin for the min priority queue class.
For a minimum priority queue, write the function for removing the minimum element present.
Remove and return the minimum element.
Note : main function is given for your reference which we are using internally to test the code.
"""

Solution :

class PriorityQueueNode:
    def __init__(self, value, priority):
        self.value = value
        self.priority = priority

class PriorityQueue:
    def __init__(self):
        self.pq = []

    def isEmpty(self):
        return self.getSize() == 0

    def getSize(self):
        return len(self.pq)

    def getMin(self):
        if self.isEmpty():
            return None
        return self.pq[0].value

    def __percolateUp(self):
        childIndex = self.getSize() - 1
        while childIndex > 0:
            parentIndex = (childIndex - 1) // 2

            if self.pq[parentIndex].priority > self.pq[childIndex].priority:
                self.pq[parentIndex], self.pq[childIndex] = self.pq[childIndex], self.pq[parentIndex]
                childIndex = parentIndex
            else:
                break

    def insert(self, ele, priority):
        pqNode = PriorityQueueNode(ele, priority)
        self.pq.append(pqNode)
        self.__percolateUp()

    def __percolatedown(self):

        parenti = 0
        lc = 2 * (parenti) + 1
        rc = 2 * (parenti) + 2
        while lc < self.getSize():
            mi = parenti
            if self.pq[mi].priority > self.pq[lc].priority:
                mi = lc
            if self.getSize() > rc and self.pq[mi].priority > self.pq[rc].priority:
                mi = rc
            if mi == parenti:
                break
            self.pq[parenti], self.pq[mi] = self.pq[mi], self.pq[parenti]
            parenti = mi
            lc = 2 * (parenti) + 1
            rc = 2 * (parenti) + 2

    def removeMin(self):
        if self.isEmpty():
            return None
        rel = self.pq[0].value
        self.pq[0] = self.pq[self.getSize() - 1]
        self.pq.pop()
        self.__percolatedown()
        return rel

myPq = PriorityQueue()
curr_input = [int(ele) for ele in input().split()]
choice = curr_input[0]
i = 1
while choice != -1:
    if choice == 1:
        element = curr_input[i]
        i += 1
        myPq.insert(element, element)
    elif choice == 2:
        print(myPq.getMin())
    elif choice == 3:
        print(myPq.removeMin())
    elif choice == 4:
        print(myPq.getSize())
    elif choice == 5:
        if myPq.isEmpty():
            print('true')
        else:
            print('false')
        break
    else:
        pass
    choice = curr_input[i]
    i += 1


#Code : Max Priority Queue
"""
Implement the class for Max Priority Queue which includes following functions -

1. getSize -
Return the size of priority queue i.e. number of elements present in the priority queue.

2. isEmpty -
Check if priority queue is empty or not. Return true or false accordingly.

3. insert -
Given an element, insert that element in the priority queue at the correct position.

4. getMax -
Return the maximum element present in the priority queue without deleting. 
Return -Infinity if priority queue is empty.

5. removeMax -
Delete and return the maximum element present in the priority queue. 
Return -Infinity if priority queue is empty.

Note : main function is given for your reference which we are using internally to test the class.
"""

Solution :

class Node:
    def __init__(self, value, priority):
        self.value = value
        self.priority = priority

class PriorityQueue:
    def __init__(self):
        self.pq = []

    def isEmpty(self):
        return self.getSize() == 0

    def getSize(self):
        return len(self.pq)

    def getMax(self):
        if self.isEmpty() is True:
            return None
        return self.pq[0].value

    def __upHeapify(self):
        child_index = self.getSize() - 1

        while child_index > 0:
            parent_index = (child_index - 1) // 2

            if self.pq[parent_index].priority < self.pq[child_index].priority:
                self.pq[parent_index], self.pq[child_index] = self.pq[child_index], self.pq[parent_index]
                child_index = parent_index
            else:
                break

    def insert(self, ele, priority):
        pqNode = Node(ele, priority)
        self.pq.append(pqNode)
        self.__upHeapify()

    def __downHeapify(self):
        parent_index = 0
        child_left_index = 2 * parent_index + 1
        child_right_index = 2 * parent_index + 2

        while child_left_index < self.getSize():
            max_index = parent_index

            if self.pq[max_index].priority < self.pq[child_left_index].priority:
                max_index = child_left_index
            if child_right_index < self.getSize() and self.pq[max_index].priority < self.pq[child_right_index].priority:
                max_index = child_right_index

            if max_index == parent_index:
                break
            self.pq[parent_index], self.pq[max_index] = self.pq[max_index], self.pq[parent_index]
            parent_index = max_index
            child_left_index = 2 * parent_index + 1
            child_right_index = 2 * parent_index + 2

    def removeMax(self):
        if self.isEmpty() is True:
            return None
        value = self.pq[0].value
        self.pq[0] = self.pq[self.getSize() - 1]
        self.pq.pop()
        self.__downHeapify()
        return value

myPq = PriorityQueue()
curr_input = [int(ele) for ele in input().split()]
choice = curr_input[0]
i = 1
while choice != -1:
    if choice == 1:
        element = curr_input[i]
        i += 1
        myPq.insert(element, element)
    elif choice == 2:
        print(myPq.getMax())
    elif choice == 3:
        print(myPq.removeMax())
    elif choice == 4:
        print(myPq.getSize())
    elif choice == 5:
        if myPq.isEmpty():
            print('true')
        else:
            print('false')
        break
    else:
        pass
    choice = curr_input[i]
    i += 1



#Inplace Heap Sort
"""
Given an integer array of size n. Sort this array (in decreasing order) using heap sort.
Space complexity should be O(1).

Input Format :
Line 1 : Integer n, Array size
Line 2 : Array elements, separated by space

Output Format :
Array elements after sorting
"""
Sample Input:
6
2 6 8 5 4 3
Sample Output:
8 6 5 4 3 2

Solution :

def heapify(arr, n, i):
    smallest = i
    l = 2 * i + 1
    r = 2 * i + 2

    if l < n and arr[l] < arr[smallest]:
        smallest = l

    if r < n and arr[r] < arr[smallest]:
        smallest = r

    if smallest != i:
        (arr[i],
         arr[smallest]) = (arr[smallest],
                           arr[i])
        heapify(arr, n, smallest)

def heapSort(arr, n):
    for i in range(int(n / 2) - 1, -1, -1):
        heapify(arr, n, i)
    for i in range(n - 1, -1, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

def printArray(arr, n):
    for i in range(n):
        print(arr[i], end=" ")
    print()

if __name__ == '__main__':
    arr_size = int(input())
    arr = list(int(i) for i in input().strip().split(' '))
    n = len(arr)
    heapSort(arr, n)
    printArray(arr, n)


#K Smallest Elements
"""
You are given with an integer k and an array of integers that contain numbers in random order. 
Write a program to find k smallest numbers from given array. You need to save them in an array and return it.
Time complexity should be O(nlogk) and space complexity should be not more than O(k).
Order of elements in the output is not important.

Input Format :
Line 1 : Size of array (n)
Line 2 : Array elements (separated by space)
Line 3 : Integer k

Output Format :
k smallest elements
"""
Sample Input :
13
2 12 9 16 10 5 3 20 25 11 1 8 6
4
Sample Output :
5
3
2
1

Solution :

import heapq

def kSmallest(arr,k):
    heap=arr[:k]
    heapq._heapify_max(heap)
    n=len(arr)
    for i in range(k,n):
        if heap[0]>arr[i]:
            heapq._heapreplace_max(heap,arr[i])
    return heap

arr_size=int(input())
arr=list(int(i) for i in input().strip().split(' '))
k=int(input())
elements=kSmallest(arr,k)
for ele in elements:
    print(ele)


#K Largest Elements
"""
You are given with an integer k and an array of integers that contain numbers in random order. 
Write a program to find k largest numbers from given array. You need to save them in an array and return it.
Time complexity should be O(nlogk) and space complexity should be not more than O(k).
Order of elements in the output is not important.

Input Format :
Line 1 : Size of array (n)
Line 2 : Array elements (separated by space)
Line 3 : Integer k

Output Format :
k largest elements
"""
Sample Input :
13
2 12 9 16 10 5 3 20 25 11 1 8 6
4
Sample Output :
12
16
20
25

Solution :

def kLargest(arr, k):
    arr.sort(reverse=True)
    for i in range(k):
        print(arr[i])

arr_size = int(input())
arr = list(int(i) for i in input().strip().split(' '))
k = int(input())
kLargest(arr, k)


#Check Max-Heap
"""
Given an array of integers, check whether it represents max-heap or not.
Return true or false.

Input Format :
Line 1 : An integer N i.e. size of the array
Line 2 : N integers which are elements of the array, separated by spaces

Output Format :
true if it represents max-heap and false if it is not a max-heap
"""

Solution :

def isHeap(arr, n):
    for i in range(int((n - 2) / 2) + 1):
        if arr[2 * i + 1] > arr[i]:
            return False

        if (2 * i + 2 < n and
                arr[2 * i + 2] > arr[i]):
            return False
    return True

if __name__ == '__main__':
    arr_size = int(input())
    arr = list(int(i) for i in input().strip().split(' '))
    n = len(arr)

    if isHeap(arr, n):
        print("true")
    else:
        print("false")


#Kth largest element
"""
Given an array A of random integers and an integer k, find and return the kth largest element in the array.
Try to do this question in less than O(nlogn) time.

Input Format :
Line 1 : An integer N i.e. size of the array
Line 2 : N integers which are elements of the array, separated by spaces
Line 3 : An integer k

Output Format :
kth largest element
"""
Sample Input 1 :
6
9 4 8 7 11 3
2
Sample Output 1 :
9
Sample Input 2 :
8
2 6 10 11 13 4 1 20
4
Sample Output 2 :
10

Solution :

def kthLargest(lst,k,length):
    lst.sort(reverse = True)
    return lst[k-1]

n=int(input())
lst=list(int(i) for i in input().strip().split(' '))
k=int(input())
length=len(lst)
ans=kthLargest(lst, k,length)
print(ans)


#Buy the ticket
"""
You want to buy a ticket for a well-known concert which is happening in your city. 
But the number of tickets available is limited. 
Hence the sponsors of the concert decided to sell tickets to customers based on some priority.
A queue is maintained for buying the tickets and every person has attached with a priority (an integer, 1 being the lowest priority). 
The tickets are sold in the following manner -

1. The first person (pi) in the queue asked to comes out.
2. If there is another person present in the queue who has higher priority than pi, then ask pi to move at end of the queue without giving him the ticket.
3. Otherwise, give him the ticket (and don't make him stand in queue again).

Giving a ticket to a person takes exactly 1 minutes and it takes no time for removing and adding a person to the queue. And you can assume that no new person joins the queue.
Given a list of priorities of N persons standing in the queue and the index of your priority (indexing starts from 0). 
Find and return the time it will take until you get the ticket.

Input Format :
Line 1 : Integer N (Total number of people standing in queue)
Line 2 : Priorities of every person (n space separated integers)
Line 3 : Integer k (index of your priority)

Output Format :
Time required
"""
Sample Input 1 :
3
3 9 4
2
Sample Output 1 :
2
Sample Output 1 Explanation :
Person with priority 3 comes out. But there is a person with higher priority than him.
So he goes and then stands in the queue at the end. Queue's status : {9, 4, 3}. Time : 0 secs.
Next, the person with priority 9 comes out. And there is no person with higher priority than him.
So he'll get the ticket. Queue's status : {4, 3}. Time : 1 secs.
Next, the person with priority 4 comes out (which is you). And there is no person with higher priority than you.
So you'll get the ticket. Time : 2 secs

Sample Input 2 :
5
2 3 2 2 4
3
Sample Output 2 :
4

Solution :

import heapq

def time_required(lst, k):
    q=lst[k]
    heapq._heapify_max(lst)
    time=0
    while True:
        ele_max = heapq._heappop_max(lst)
        time+=1
        if ele_max==q:
            return time

n=int(input())
lst=list(int(i) for i in input().strip().split(' '))
k=int(input())
ans=time_required(lst, k)
print(ans)



#Min Steps To 1
"""
Given a positive integer n, find the minimum number of steps s, that takes n to 1.
You can perform any one of the following 3 steps.
1.) Subtract 1 from it. (n= n - ­1) ,
2.) If its divisible by 2, divide by 2.( if n%2==0, then n= n/2 ) ,
3.) If its divisible by 3, divide by 3. (if n%3 == 0, then n = n / 3 ).
The time complexity of your code should be O(n).

Input format :
Line 1 : A single integer i.e. n

Output format :
Line 1 : Single integer i.e number of steps
"""
Sample Input 1 :
4
Sample Output 1 :
2
Sample Output 1 Explanation :
For n = 4
Step 1 : n = 4/2 = 2
Step 2 : n = 2/2 = 1

Sample Input 2 :
7
Sample Output 2 :
3
Sample Output 2 Explanation :
For n = 7
Step 1 : n = 7 ­ - 1 = 6
Step 2 : n = 6 / 3 = 2
Step 3 : n = 2 / 2 = 1

Solution :

def minStepsTo1DP(n):
    ''' Return Minimum no of steps required to reach 1 using using Dynamic Prog'''
    storage=[-1]*(n+1)
    storage[0]=0
    storage[1]=0
    bigNumber=2147483647
    for i in range(2,n+1):
        op1=storage[i-1]
        op2=storage[i//2] if i%2==0 else bigNumber
        op3=storage[i//3] if i%3==0 else bigNumber
        storage[i]=1+min(op1,op2,op3)
    return storage[n]

    pass

n=int(input())
print(minStepsTo1DP(n))


#Minimum Number Of Squares
"""
A number can always be represented as a sum of squares of other numbers. 
Note that 1 is a square and we can always break a number as [(1 * 1) + (1 * 1) + (1 * 1) + …]. 
Given a number n, find the minimum number of squares that sum to n.

Input format:
The first and only line of input contains an integer N (1 <= N <= 10000)

Output format:
The first and only line of output contains the minimum number if squares that sum to n.
"""
Sample Test Cases:
Sample Input 1:
100
Sample Output 1:
1
Explanation:
We can write 100 as 10^2 also, 100 can be written as (5^2) + (5^2) + (5^2) + (5^2),
but this representation requires 4 squares.
So, in this case, the expected answer would be 1, that is, 10^2.

Solution :

import sys, math

def minStepsTo1(n):
    dp = [-1 for i in range(n + 1)]
    dp[0] = 0

    for i in range(1, n + 1):
        ans = sys.maxsize
        root = int(math.sqrt(i))

        for j in range(1, root + 1):
            cur_ans = 1 + dp[i - (j ** 2)]
            ans = min(ans, cur_ans)
        dp[i] = ans
    return dp[n]

n = int(input())
ans = minStepsTo1(n)
print(ans)


#Longest Increasing Subsequence
"""
Given an array with N elements, 
you need to find the length of the longest subsequence of a given sequence such that all elements of the subsequence are sorted in strictly increasing order.

Input Format
Line 1 : An integer N 
Line 2 : Elements of arrays separated by spaces

Output Format
Line 1 : Length of longest subsequence
"""
Sample Input :
6
5 4 11 1 16 8
Sample Output 1 :
3
Sample Output Explanation
Length of longest subsequence is 3 i.e. (5,11,16) or (4,11,16).
Sample Input 2:
3
1 2 2
Sample Output 2 :
2

Solution :

def lis(arr):
    n = len(arr)
    dp = [-1 for i in range(n)]
    dp[n - 1] = 1
    i = n - 2
    while i >= 0:
        including_max = 1
        further_including_max = 0
        for j in range(i + 1, n):

            if arr[j] > arr[i]:
                further_including_max = dp[j]

            including_max = max(including_max, 1 + further_including_max)
        dp[i] = including_max
        i -= 1
    return max(dp)

n = int(input())
li = [int(ele) for ele in input().split()]
print(lis(li))




#Min Cost Path Problem
"""
Given an integer matrix of size m*n,
you need to find out the value of minimum cost to reach from the cell (0, 0) to (m-1, n-1).
From a cell (i, j), you can move in three directions : (i+1, j), (i, j+1) and (i+1, j+1).
Cost of a path is defined as the sum of values of each cell through which path passes.

Input Format :
Line 1 : Two integers, m and n
Next m lines : n integers of each row (separated by space)

Output Format :
Minimum cost
"""
Sample Input :
3 4
3 4 1 2
2 1 8 9
4 7 8 1
Sample Output :
13

Solution :

import sys

def minCost(cost,m,n):
    dp=[[sys.maxsize for i in range(n+1)] for j in range(m+1)]
    for i in range(m-1,-1,-1):
        for j in range(n-1,-1,-1):
            if i==m-1 and j== n-1:
                dp[i][j] = cost[i][j]
            else:
                ans1=dp[i+1][j]
                ans2=dp[i][j+1]
                ans3=dp[i+1][j+1]
                dp[i][j] = cost[i][j] + min (ans1, ans2, ans3)
    return dp[0][0]

m,n=[int(i) for i in input().split()]
cost=[[int(j) for j in input().split()] for i in range(m)]
print(minCost(cost,m,n))


#LCS - Problem
"""
Given 2 strings of S1 and S2 with lengths m and n respectively, find the length of longest common subsequence.
A subsequence of a string S whose length is n, 
is a string containing characters in same relative order as they are present in S, 
but not necessarily contiguous. Subsequences contain all the strings of length varying from 0 to n. 
E.g. subsequences of string "abc" are - "",a,b,c,ab,bc,ac,abc.

Input Format :
Line 1 : String S1
Line 2 : String s2

Output Format :
Line 1 : Length of lcs
"""
Sample Input :
adebc
dcadb
Sample Output :
3

Solution :

def lcs(S1 , S2):
    m = len(S1)
    n = len(S2)
    L = [[None]*(n+1) for i in range(m+1)]

    for i in range(m+1):
        for j in range(n+1):
            if i == 0 or j == 0 :
                L[i][j] = 0
            elif S1[i-1] == S2[j-1]:
                L[i][j] = L[i-1][j-1]+1
            else:
                L[i][j] = max(L[i-1][j] , L[i][j-1])

    return L[m][n]

S1 = input().strip()
S2 = input().strip()
print(lcs(S1, S2))


#0 1 Knapsack - Problem
"""
A thief robbing a store and can carry a maximal weight of W into his knapsack. 
There are N items and ith item weigh wi and is value vi. What is the maximum value V, that thief can take ?

Input Format :
Line 1 : N i.e. number of items
Line 2 : N Integers i.e. weights of items separated by space
Line 3 : N Integers i.e. values of items separated by space
Line 4 : Integer W i.e. maximum weight thief can carry

Output Format :
Line 1 : Maximum value V
"""
Sample Input :
4
1 2 4 5
5 4 8 6
5
Sample Output :
13

Solution :

def knapSack(W, wt, val, n):
    K = [[0 for x in range(W + 1)] for x in range(n + 1)]
    for i in range(n + 1):
        for w in range(W + 1):
            if i == 0 or w == 0:
                K[i][w] = 0
            elif wt[i - 1] <= w:
                K[i][w] = max(val[i - 1] + K[i - 1][w - wt[i - 1]], K[i - 1][w])
            else:
                K[i][w] = K[i - 1][w]

    return K[n][W]

N = int(input())
wt = list(int(i) for i in input().strip().split(' '))
val = list(int(i) for i in input().strip().split(' '))
W = int(input())
n = len(val)
print(knapSack(W, wt, val, n))


#Matrix Chain Multiplication
"""
Given a chain of matrices A1, A2, A3,.....An, you have to figure out the most efficient way to multiply these matrices 
i.e. determine where to place parentheses to minimise the number of multiplications.
You will be given an array p[] of size n + 1. Dimension of matrix Ai is p[i - 1]*p[i]. 
You need to find minimum number of multiplications needed to multiply the chain.

Input Format :
Line 1 : Integer n i.e. number of matrices
Line 2 : n + 1 integers i.e. elements of array p[] 

Output Format :
Line 1 : Minimum number of multiplication needed
"""
Sample Input :
3
10 15 20 25
Sample Output :
8000
Sample Output Explanation :
There are two ways to multiply the chain - A1*(A2*A3) or (A1*A2)*A3.
If multiply in order A1*(A2*A3) then number of multiplications required are 15000.
If multiply in order (A1*A2)*A3 then number of multiplications required are 8000.
Thus minimum number of multiplications required are 8000

Solution :

import sys

def MatrixChainOrder(p, n):
    m = [[0 for x in range(n)] for x in range(n)]
    for i in range(1, n):
        m[i][i] = 0
    for L in range(2, n):
        for i in range(1, n-L+1):
            j = i+L-1
            m[i][j] = sys.maxsize
            for k in range(i, j):
                q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]
                if q < m[i][j]:
                    m[i][j] = q
    return m[1][n-1]

N=int(input())
arr =[int(x) for x in input().split()]
size = len(arr)
print(str(MatrixChainOrder(arr, size)))




#N-Queens
"""
You are given N, and for a given N x N chessboard, find a way to place N queens such that no queen can attack any other queen on the chess board.
A queen can be killed when it lies in the same row, or same column, or the same diagonal of any of the other queens.
You have to print all such configurations.

Input Format :
Line 1 : Integer N

Output Format :
One Line for every board configuration.
Every line will have N*N board elements printed row wise and are separated by space

Note : Don't print anything if there isn't any valid configuration.
"""
Sample Input :
4
Sample Output :
0 1 0 0 0 0 0 1 1 0 0 0 0 0 1 0
0 0 1 0 1 0 0 0 0 0 0 1 0 1 0 0

Solution :

def isSafe(row,col,board,n):
    i= row-1
    while i >= 0:
        if board[i][col]==1:
            return False
        i-=1
    i=row-1
    j=col-1
    while i >=0 and j>=0:
        if board[i][j]==1:
            return False
        i-=1
        j-=1
    i=row-1
    j=col+1
    while i >=0 and j<n:
        if board[i][j]==1:
            return False
        i-=1
        j+=1
    return True

def printPathsHelper(row,n,board):
    if row==n:
        for i in range(n):
            for j in range(n):
                print(board[i][j],end=" ")
        print()
        return
    for col in range(n):
        if isSafe(row,col,board,n) is True:
            board[row][col]=1
            printPathsHelper(row+1,n,board)
            board[row][col]=0
    return

def printPaths(n):
    board=[[0 for j in range(n)] for i in range(n)]
    printPathsHelper(0,n,board)

n= int(input())
printPaths(n)


#Sudoku Solver
"""
Given a 9*9 sudoku board, in which some entries are filled and others are 0 (0 indicates that the cell is empty), 
you need to find out whether the Sudoku puzzle can be solved or not i.e. return true or false.

Input Format :
9 Lines where ith line contains ith row elements separated by space

Output Format :
true or false
"""
Sample Input :
9 0 0 0 2 0 7 5 0
6 0 0 0 5 0 0 4 0
0 2 0 4 0 0 0 1 0
2 0 8 0 0 0 0 0 0
0 7 0 5 0 9 0 6 0
0 0 0 0 0 0 4 0 1
0 1 0 0 0 5 0 8 0
0 9 0 0 7 0 0 0 4
0 8 2 0 4 0 0 0 6
Sample Output :
true

Solution :

def print_grid(arr):
    for i in range(9):
        for j in range(9):
            print(arr[i][j])
        print('n')

def find_empty_location(arr, l):
    for row in range(9):
        for col in range(9):
            if (arr[row][col] == 0):
                l[0] = row
                l[1] = col
                return True
    return False

def used_in_row(arr, row, num):
    for i in range(9):
        if (arr[row][i] == num):
            return True
    return False

def used_in_col(arr, col, num):
    for i in range(9):
        if (arr[i][col] == num):
            return True
    return False

def used_in_box(arr, row, col, num):
    for i in range(3):
        for j in range(3):
            if (arr[i + row][j + col] == num):
                return True
    return False

def check_location_is_safe(arr, row, col, num):
    return not used_in_row(arr, row, num) and not used_in_col(arr, col, num) and not used_in_box(arr, row - row % 3,
                                                                                                 col - col % 3, num)

def solve_sudoku(arr):
    l = [0, 0]

    if (not find_empty_location(arr, l)):
        return True

    row = l[0]
    col = l[1]

    for num in range(1, 10):

        if (check_location_is_safe(arr, row, col, num)):

            arr[row][col] = num

            if (solve_sudoku(arr)):
                return True

            arr[row][col] = 0

    return False

if __name__ == "__main__":

    grid = [[0 for x in range(9)] for y in range(9)]

    grid = [[int(ele) for ele in input().split()] for i in range(9)]

    if (solve_sudoku(grid)):
        print("true")
    else:
        print("false")



#Find average Marks
"""
Write a program to input marks of three tests of a student (all integers).
Then calculate and print the average of all test marks.
"""
a = int(input())
b = int(input())
c = int(input())
Average = (a + b + c) / 3
print(Average)


#Find X raised to power N
"""
You are given two integers: X and N. 
You have to calculate X raised to power N and print it.
"""
X = int(input())
N = int(input())
Output = X**N
print(Output)


#Arithmetic Progression
"""
You are given first three entries of an arithmetic progression.
You have to calculate the common difference and print it.
"""
a = int(input())
b = int(input())
c = int(input())
d = b - a
#or
d = c - b
print(d)


#Rectangular Area
"""
You are given a rectangle in a plane. The corner coordinates of this rectangle is provided to you.
You have to print the amount of area of the plane covered by this rectangles.
The end coordinates are provided as four integral values: x1, y1, x2, y2.
It is given that x1 < x2 and y1 < y2.
"""
x1 = int(input())
y1 = int(input())
x2 = int(input())
y2 = int(input())
Area = (x2 - x1) * (y2 - y1)
print(Area)




#Check number
"""
Given an integer n, find if n is positive, negative or 0.
If n is positive, print "Positive"
If n is negative, print "Negative"
And if n is equal to 0, print "Zero".
"""
Input Format : Integer n
Output Format : "Positive" or "Negative" or "Zero" (without double quotes)

Solution :
n = int(input())
if n >= 1 :
    print("Positive")
elif n <= -1 :
    print("Negative")
else :
    print("Zero")


#Sum of n numbers
"""
Given an integer n, find and print the sum of numbers from 1 to n.
Note : Use while loop only.
"""
Input Format : Integer n
Output Format : Sum

Solution :
n = int(input())
count = 1
sum = 0
while count <= n:
    sum = sum + count
    count = count + 1
print(sum)


#Sum of Even Numbers
"""
Given a number N, print sum of all even numbers from 1 to N.
"""
Input Format : Integer N
Output Format : Required Sum

Solution :
n = int(input())
count = 2
sum = 0
while count <= n:
    sum = sum + count
    count = count + 2
print(sum)


#Fahrenheit to Celsius
"""
Given three values - Start Fahrenheit Value (S), End Fahrenheit value (E) and Step Size (W),
you need to convert all Fahrenheit values from Start to End at the gap of W,
into their corresponding Celsius values and print the table.
"""
Input Format : 3 integers - S, E and W respectively
Output Format : Fahrenheit to Celsius conversion table.
                One line for every Fahrenheit and corresponding Celsius value.
                On Fahrenheit value and its corresponding Celsius value should be separate by tab ("\t")

Solution :
fh1 = int(input())
fh2 = int(input())
step = int(input())
cth = fh1
while cth <= fh2:
    c = int((cth - 32) * 5 / 9)
    print(str(cth) + "\t" + str(c))
    cth = cth + step


#Calculator
"""
1. If the input is 1, 2 integers are taken from the user and their sum is printed.
2. If the input is 2, 2 integers are taken from the user and their difference(1st number - 2nd number) is printed.
3. If the input is 3, 2 integers are taken from the user and their product is printed.
4. If the input is 4, 2 integers are taken from the user and the quotient obtained (on dividing 1st number by 2nd number) is printed.
5. If the input is 5, 2 integers are taken from the user and their remainder(1st number mod 2nd number) is printed.
6. If the input is 6, the program exits.
7. For any other input, print "Invalid Operation".
"""
Input format: Take integers as input, in accordance to the description of the question.
Output format: The output lines must be as prescribed in the description of the question.

Solution :
while (True):
    ch=int(input())
    if(ch==1):
        a=int(input())
        b=int(input())
        c=a+b
        print(c)
    elif(ch==2):
        a=int(input())
        b=int(input())
        c=a-b
        print(c)
    elif(ch==3):
        a=int(input())
        b=int(input())
        c=a*b
        print(c)
    elif(ch==4):
        a=int(input())
        b=int(input())
        c=a//b
        print(c)
    elif(ch==5):
        a=int(input())
        b=int(input())
        c=a%b
        print(c)
    elif(ch==6):
        break
    else:
        print("Invalid Operation")


#Reverse of a number
"""
Write a program to generate the reverse of a given number N. Print the corresponding reverse number.
Note : If a number has trailing zeros, then its reverse will not include them. 
For e.g., reverse of 10400 will be 401 instead of 00401.
"""
Input format : Integer N
Output format : Corresponding reverse number

Solution :
n = int(input())
rev = 0
while n > 0:
    l = n % 10
    n = n // 10
    rev = rev * 10 + l
print(rev)


#Palindrome number
"""
Write a program to determine if given number is palindrome or not. Print true if it is palindrome, false otherwise.
Palindrome are the numbers for which reverse is exactly same as the original one. For eg. 121
"""
Sample Input : 121
Sample Output : true

Solution :
n = int(input())
nclone = n
rev = 0
while n > 0:
    l = n % 10
    n = n//10
    rev = rev * 10 + l
if nclone == rev:
    print("true")
else :
    print("false")


#Sum of even & odd
"""
Write a program to input an integer N and print the sum of all its even digits and sum of all its odd digits separately.
Digits mean numbers, not the places!
That is, if the given integer is "13245", even digits are 2 & 4 and odd digits are 1, 3 & 5.
"""
Input format : Integer N
Output format : Sum_of_Even_Digits Sum_of_Odd_Digits
                (Print first even sum and then odd sum separated by space)
Sample Input 1: 1234
Sample Output 1: 6 4

Solution :
n = int(input())
evensum = 0
oddsum = 0
while (n>0):
    d = n % 10
    if d % 2==0:
        evensum = evensum + d
    else:
        oddsum = oddsum + d
    n = n//10
print (evensum,"",oddsum)


#Nth Fibonacci number
"""
Nth term of fibonacci series F(n) is calculated using following formula -
    F(n) = F(n-1) + F(n-2), 
    Where, F(1) = F(2) = 1
Provided N you have to find out the Nth Fibonacci Number.
"""
Input Format : Integer n
Output Format : Nth Fibonacci term i.e. F(n)
Sample Input 1: 4
Sample Output 2: 3

Solution :
n = int(input())
counter = 1
first = 1
second = 1
while counter < n:
    temp = first + second
    first = second
    second = temp
    counter = counter + 1
print(first)




#Square Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    4444
    4444
    4444
    4444
"""
Sample Input 1:
7
Sample Output 1:
7777777
7777777
7777777
7777777
7777777
7777777
7777777

Solution :
n = int(input())
i = 1
while i <= n:
    j = 1
    while j <= n:
        print(n , end="")
        j = j + 1
    print()
    i = i + 1


#Triangular Star Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    *
    **
    ***
    ****
Note : There are no spaces between the stars (*)
"""
Sample Input :
5
Sample Output :
*
**
***
****
*****

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    while j <= i:
        print("*" , end = "")
        j = j + 1
    print()
    i = i +1


#Triangle Number Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    1
    22
    333
    4444
"""
Sample Input :
5
Sample Output :
1
22
333
4444
55555

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    while j <= i:
        print(i , end = "")
        j = j + 1
    print()
    i = i +1


#Reverse Number Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    1
    21
    321
    4321
"""
Sample Input :
5
Sample Output :
1
21
321
4321
54321

Solution :
n = int(input())
i = 1
while i <= n:
    j = 1
    while j <= i:
        print(i - j + 1 , end = "")
        j = j + 1
    print()
    i = i + 1


#Character Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    A
    BC
    CDE
    DEFG
"""
Sample Input :
5
Sample Output :
A
BC
CDE
DEFG
EFGHI

Solution :
n = int(input())
i = 1
while i <= n:
    j = 1
    start = chr(ord('A')+i-1)
    while j <= i:
        charP = chr(ord(start)+j-1)
        print(charP , end = "")
        j = j + 1
    print()
    i = i + 1


#Interesting Alphabets
"""
Print the following pattern for the given number of rows.
Pattern for N = 5
    E
    DE
    CDE
    BCDE
    ABCDE
"""
Sample Input :
8
Sample Output :
H
GH
FGH
EFGH
DEFGH
CDEFGH
BCDEFGH
ABCDEFGH

Solution :
n = int(input())
i = 1
start = chr(ord('A') + n -1)

while i <= n:
    j = 1
    while j <= i:
        charP = chr(ord(start)-i+j)
        print(charP , end = "")
        j = j + 1
    print()
    i = i + 1


#Number Pattern 1
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    1
    11
    111
    1111
"""
Sample Input :
5
Sample Output :
1
11
111
1111
11111

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    while j <= i:
        print("1" , end = "")
        j = j + 1
    print()
    i = i +1


#Number Pattern 2
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    1
    11
    202
    3003
"""
Sample Input :
5
Sample Output :
1
11
202
3003
40004

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    while j <= i:
        if (j == 1) or (j == i):
            if (i-1==0):
                print("1" , end = "")
            else:
                print(i-1 , end = "")
        else:
            print("0" , end = "")
        j = j + 1
    print()
    i = i +1


#Number Pattern 3
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    1
    11
    121
    1221
"""
Sample Input :
5
Sample Output :
1
11
121
1221
12221

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    while j <= i:
        if (j == 1) or (j == i):
            print("1" , end = "")
        else:
            print("2" , end = "")
        j = j + 1
    print()
    i = i +1


#Number Pattern 4
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    1234
    123
    12
    1
"""
Sample Input :
5
Sample Output :
12345
1234
123
12
1

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    while j <= n-i+1:
        print(j , end = "")
        j = j + 1
    print()
    i = i +1


#Alpha Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 3
    A
    BB
    CCC
"""
Sample Input :
7
Sample Output :
A
BB
CCC
DDDD
EEEEE
FFFFFF
GGGGGGG

Solution :
n = int(input())
i = 1
while i <= n :
    j = 1
    start = chr(ord('A'))
    while j <= i:
        charP = chr(ord(start)+i-1)
        print(charP , end = "")
        j = j + 1
    print()
    i = i +1



#Inverted Number Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    4444
    333
    22
    1
"""
Sample Input :
5
Sample Output :
55555
4444
333
22
1

Solution :
n = int(input())
i = 1
while i <= n:
    j = 1
    while j <= n - i + 1:
        print(n-i+1 , end = "")
        j = j+1
    print()
    i = i + 1


#Mirror Number Pattern
"""
Print the following pattern for the given N number of rows.
Pattern for N = 4
    ...1
    ..12
    .123
    1234
The dots represent spaces.
"""
Sample Input :
3
Sample Output :
  1
 12
123

Solution :
n = int(input())
i = 1
while i <= n:
    s = 1
    while s <= n-i:
        print(" ",end="")
        s = s + 1
    j = 1
    while j <= i:
        print(j,end ="")
        j = j+1
    print()
    i = i+1


#Star Pattern
"""
Print the following pattern
Pattern for N = 4
    ...*
    ..***
    .*****
    *******
The dots represent spaces.
"""
Sample Input  :
3
Sample Output  :
   *
  ***
 *****

Solution :
n = int(input())
i = 1
while i <= n:
    s = 1
    while s <= n-i:
        print(" " , end = "")
        s = s + 1
    star = 1
    while star <= i:
        print("*" , end = "")
        star = star + 1
    star2=i-1
    while star2>=1:
        print("*",end="")
        star2 = star2-1
    print()
    i = i+1


#Triangle of Numbers
"""
Print the following pattern for the given number of rows.
Pattern for N = 4
    ...1
    ..232
    .34543
    4567654
The dots represent spaces.
"""
Sample Input :
5
Sample Output :
           1
          232
         34543
        4567654
       567898765

Solution :
n = int(input())
i = 1
while i <= n:
    s = 1
    while s<=n-i:
        print(" ",end="")
        s=s+1
    j = 1
    p = i
    while j <= i:
        print(p , end = "")
        j = j + 1
        p = p + 1
    n2=2*(i-1)
    while n2>=i:
        if i>1:
            print(n2,end="")
        n2=n2-1
    print()
    i = i + 1


#Diamond of stars
"""
Print the following pattern for the given number of rows.
Note: N is always odd.
Pattern for N = 5
    ..*
    .***
    *****
    .***
    ..*
The dots represent spaces.
"""
Sample Input :
3
Sample Output :
  *
 ***
  *

Solution :
n = int(input())
i = 1
n1 = (n+1)/2
while i <= n1:
    space = 1
    while space <=n1-i:
        print(" ",end="")
        space = space+1
    star = 1
    while star <= (2*i-1):
        print("*",end="")
        star = star+1
    print()
    i = i+1
i=1
n2=n/2
while i<=n2:
    space2=1
    while space2 <= i:
        print(" ",end="")
        space2 = space2+1
    star2=n-2*i
    while star2 > 0:
        print("*",end="")
        star2=star2-1
    print()
    i=i+1


#Number Pattern
"""
Print the following pattern for n number of rows.
For eg. N = 5

1        1
12      21
123    321
1234  4321
1234554321
"""
Sample Input :
4
Sample Output :
1      1
12    21
123  321
12344321

Solution :
n = int(input())
for i in range(1,n+1,1):
    for j in range (1,i+1,1):
        print(j,end="")
    for s in range((2*n)-2*i,0,-1):
        print(" ",end="")
    for n2 in range (i,0,-1):
        print(n2,end="")

    print()


#Zeros and Stars Pattern
"""
Print the following pattern
Pattern for N = 4
*000*000*
0*00*00*0
00*0*0*00
000***000
"""
Sample Input :
3
Sample Output :
*00*00*
0*0*0*0
00***00

Solution :
n = int(input())
for i in range(1,n+1,1):
    for j in range(1,2*n+2,1):
        if i==j or i+j==2*n+2 or j == n+1:
            print("*",end="")
        else:
            print("0",end="")
    print()


#Pyramid Number Pattern
"""
Print the following pattern for the given number of rows.
Pattern for N = 4
       1
      212
     32123
    4321234
Input format : N (Total no. of rows)
Output format : Pattern in N lines
"""
Sample Input :
5
Sample Output :
        1
       212
      32123
     4321234
    543212345

Solution :
n = int(input())
for i in range(1,n+1,1):
    for s in range(n-i):
        print(" ",end ="")
    for j in range(i,0,-1):
        print(j,end="")
    for j in range(2,i+1,1):
        if i!=1:
             print(j,end="")
    print()


#Arrow pattern
"""
Print the following pattern for the given number of rows.
Assume N is always odd.
Note : There is space after every star.
Pattern for N = 7

*
 * *
   * * *
     * * * *
   * * *
 * *
*

"""
Sample Input :
11
Sample Output :
*
 * *
   * * *
     * * * *
       * * * * *
         * * * * * *
       * * * * *
     * * * *
   * * *
 * *
*

Solution :
n = int(input())
i = 0
while(i<n):
    k=1
    j=0
    if(i<n//2):
        while(k<=i):
            print(" ",end="")
            k=k+1
        while(j<=i):
            print("* ",end="")
            j=j+1
    else:
        k=i
        j=i
        while(k<n-1):
            print(" ",end="")
            k=k+1
        while(j<=n-1):
            print("* ",end="")
            j=j+1
    i=i+1
    print()



#Binary Pattern
"""
Print the following pattern for the given number of rows.
Pattern for N = 4
    1111
    000
    11
    0
Input format : N (Total no. of rows)
Output format : Pattern in N lines
"""
Sample Input :
5
Sample Output :
11111
0000
111
00
1

Solution :
n=int(input())
for i in range(1,n+1,1):
    for j in range(n-i+2,1,-1):
        if i % 2==0:
            print("0",end="")
        else:
            print("1",end="")
    print()


#Print Number Pyramid
"""
Print the following pattern for a given n.
For eg. N = 6

123456
 23456
  3456
   456
    56
     6
    56
   456
  3456
 23456
123456

"""
Sample Input 1 :
4
Sample Output 1 :
1234
 234
  34
   4
  34
 234
1234

Solution :
n = int(input())
for i in range (1,2*n,1):
    for j in range(1,n+1,1):
        if i > j and i + j < 2*n:
            print(" ", end="")
        else:
            print(j,end="")
    print()


#Rectangular numbers
"""
Print the following pattern for the given number of rows.
Pattern for N = 4

    4444444
    4333334
    4322234
    4321234
    4322234
    4333334  
    4444444
    
Input format : N (Total no. of rows)
Output format : Pattern in N lines
"""
Sample Input :
3
Sample Output :
33333
32223
32123
32223
33333

Solution :
n = int(input())
i = 1-n
while i<n:
    j=1-n
    while j<n:
        v=1+max(abs(i),abs(j))
        print(v,end="")
        j=j+1
    print()
    i=i+1


#Print the pattern
"""
Print the following pattern for the given number of rows.

Pattern for N = 5

 1    2   3    4   5
 11   12  13   14  15
 21   22  23   24  25
 16   17  18   19  20
 6    7    8   9   10
 
Input format : N (Total no. of rows)
Output format : Pattern in N lines
"""
Sample Input :
4
Sample Output :
 1  2  3  4
 9 10 11 12
13 14 15 16
 5  6  7  8

Solution :
n = int(input())
z = 1
for i in range(1, n + 1, 1):
    toprint = (z - 1) * n + 1
    for j in range(toprint, toprint + n, 1):
        print(j, end=" ")
    if i < int((n + 1) / 2):
        z = z + 2
    elif i == int((n + 1) / 2):

        if n % 2 == 0:
            z = z + 1
        else:
            z = z - 1

    else:
        z = z - 2
    print()




#Fahrenheit to Celsius Function
"""
Given three values - Start Fahrenheit Value (S), End Fahrenheit value (E) and Step Size (W),
you need to convert all Fahrenheit values from Start to End at the gap of W,
into their corresponding Celsius values and print the table.

Input Format :
3 integers - S, E and W respectively

Output Format :
Fahrenheit to Celsius conversion table.
One line for every Fahrenheit and Celsius Fahrenheit value.
Fahrenheit value and its corresponding Celsius value should be separate by tab ("\t")
"""
Sample Input 1:
0
100
20
Sample Output 1:
0   -17
20  -6
40  4
60  15
80  26
100 37
Sample Input 2:
120
200
40
Sample Output 2:
120 48
160 71
200 93

Solution :
s=int(input())
e=int(input())
st=int(input())
def conversion(start,end,step):
    for f in range(start,end,step):
        cel=int((f-32)*5/9)
        print(str(f)+"\t"+str(cel))
conversion(s,e,st)


#Fibonacci Member
"""
Given a number N, figure out if it is a member of fibonacci series or not. 
Return true if the number is member of fibonacci series else false.
Fibonacci Series is defined by the recurrence
        F(n) = F(n-1) + F(n-2)
     where F(0) = 0 and F(1) = 1

Input Format :
Integer N

Output Format :
true or false
"""
Sample Input 1 :
5
Sample Output 1 :
true

Sample Input 2 :
14
Sample Output 2 :
false

Solution :
def checkMemberNPrint(n):
    curr = 1
    prev = 1
    while (curr < n):
        temp = curr + prev
        prev = curr
        curr = temp
    if curr == n:
        print("true")
    else:
        print("false")

n = int(input())
checkMemberNPrint(n)


#Palindrome number
"""
Write a program to determine if given number is palindrome or not. 
Print true if it is palindrome, false otherwise.
Palindrome are the numbers for which reverse is exactly same as the original one. For eg. 121
"""
Sample Input 1 :
121
Sample Output 1 :
true
Sample Input 2 :
1032
Sample Output 2 :
false

Solution :
n = int(input())
nclone = n
rev = 0
while n > 0:
    l = n % 10
    n = n//10
    rev = rev * 10 + l
if nclone == rev:
    print("true")
else :
    print("false")


#Check Armstrong
"""
Write a Program to determine if the given number is Armstrong number or not. 
Print true if number is armstrong, otherwise print false.
An Armstrong number is a number (with digits n) 
such that the sum of its digits raised to nth power is equal to the number itself.

For example,
371, as 3^3 + 7^3 + 1^3 = 371
1634, as 1^4 + 6^4 + 3^4 + 4^4 = 1634

Input Format :
Integer n
Output Format :
true or false

"""
Sample Input 1 :
1
Sample Output 1 :
true
Sample Input 2 :
103
Sample Output 2 :
false

Solution :
num = int(input())
order = len(str(num))
sum = 0
temp = num
while temp > 0:
   digit = temp % 10
   sum += digit ** order
   temp //= 10
if num == sum:
   print("true")
else:
   print("false")



#Array Sum
"""
Given an array of length N, you need to find and print the sum of all elements of the array.

Input Format :
Line 1 : An Integer N i.e. size of array
Line 2 : N integers which are elements of the array, separated by spaces

Output Format :
Sum
"""
Sample Input :
3
9 8 9
Sample Output :
26

Solution :
n=int(input())
li=[int(x) for x in input().split()]
sum = 0
for list_ele in li:
    sum=sum+list_ele
print(sum)


#Swap Alternate
"""
You have been given an array/list(ARR) of size N. 
You need to swap every pair of alternate elements in the array/list.
You don't need to print or return anything, just change in the input array itself.

Input Format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
First line of each test case or query contains an integer 'N' representing the size of the array/list.
Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the elements of the resulting array in a single row separated by a single space.
Output for every test case will be printed in a separate line.

"""
Sample Input 1:
1
6
9 3 6 12 4 32
Sample Output 1 :
3 9 12 6 32 4
Sample Input 2:
2
9
9 3 6 12 4 32 5 11 19
4
1 2 3 4
Sample Output 2 :
3 9 12 6 32 4 11 5 19
2 1 4 3

Solution :
def swappairwise(li):
  l = len(li)&-2
  li[1:l:2],li[:l:2] = li[:l:2],li[1:l:2]
n=int(input())
li=[int(x) for x in input().split()]
swappairwise(li)
for x in li:
    print(x,end=" ")


#Find Unique
"""
You have been given an integer array/list(ARR) of size N. Where N is equal to [2M + 1].
Now, in the given array/list, 'M' numbers are present twice and one number is present only once.
You need to find and return that number which is unique in the array/list.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.
First line of each test case or query contains an integer 'N' representing the size of the array/list.
Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the unique element present in the array.
Output for every test case will be printed in a separate line.

"""
Sample Input 1:
1
7
2 3 1 6 3 6 2
Sample Output 1:
1
Sample Input 2:
2
5
2 4 7 2 7
9
1 3 1 3 6 6 7 10 7
Sample Output 2:
4
10

Solution :
def find_unique(li):
    ele = li[0]
    for i in range(1, len(li)):
        ele = ele ^ li[i]
    return ele
n = int(input())
li = [int(x) for x in input().split()]
unique = find_unique(li)
print(unique)


#Find Duplicate
"""
You have been given an integer array/list(ARR) of size N which contains numbers from 0 to (N - 2). 
Each number is present at least once.
That is, if N = 5, the array/list constitutes values ranging from 0 to 3 and among these,
there is a single integer value that is present twice. 
You need to find and return that duplicate number present in the array.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.
First line of each test case or query contains an integer 'N' representing the size of the array/list.
Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the duplicate element in the array/list.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
9
0 7 2 5 4 7 1 3 6
Sample Output 1:
7
Sample Input 2:
2
5
0 2 1 3 1
7
0 3 1 5 4 3 2
Sample Output 2:
1
3

Solution :
def Repeat(x):
    _size = len(x)
    repeated = []
    for i in range(_size):
        k = i + 1
        for j in range(k, _size):
            if x[i] == x[j] and x[i] not in repeated:
                repeated.append(x[i])
    return repeated
n = int(input())
list1 = [int(x) for x in input().split()]
for x in Repeat(list1):
    print(x, end=" ")


#Array Intersection
"""
You have been given two integer arrays/list(ARR1 and ARR2) of size M and N, respectively.
You need to print their intersection; 
An intersection for this problem can be defined when both the arrays/lists contain a particular value or to put it in other words, 
when there is a common value that exists in both the arrays/lists.

Note :
Input arrays/lists can contain duplicate elements.
The intersection elements printed would be in the order they appear in the first array/list(ARR1)

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the first array/list.

Second line contains 'N' single space separated integers representing the elements of the first the array/list.

Third line contains an integer 'M' representing the size of the second array/list.

Fourth line contains 'M' single space separated integers representing the elements of the second array/list.

Output format :
For each test case, print the intersection elements in a row, separated by a single space.

Output for every test case will be printed in a separate line.
"""
Sample Input 1 :
2
6
2 6 8 5 4 3
4
2 3 4 7
2
10 10
1
10
Sample Output 1 :
2 4 3
10
Sample Input 2 :
1
4
2 6 1 2
5
1 2 3 4 2
Sample Output 2 :
2 1 2
Explanation for Sample Output 2 :
Since, both input arrays have two '2's, the intersection of the arrays also have two '2's.
The first '2' of first array matches with the first '2' of the second array.
Similarly, the second '2' of the first array matches with the second '2' if the second array.

Solution :
m=float(input())
lst1=[int(x) for x in input().split()]
n=float(input())
lst2=[int(x) for x in input().split()]
for i in range (len(lst1)):
    for j in range (len(lst2)):
        if lst1[i]==lst2[j]:
            print(lst1[i])
            lst2[j]=float("-inf")
            break


#Pair Sum
"""
You have been given an integer array/list(ARR) and a number X.
Find and return the total number of pairs in the array/list which sum to X.

Note:
Given array/list can contain duplicate elements.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the first array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Third line contains an integer 'X'.
Output format :
For each test case, print the total number of pairs present in the array/list.

Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
9
1 3 6 2 5 4 3 2 4
7
Sample Output 1:
7
Sample Input 2:
2
9
1 3 6 2 5 4 3 2 4
12
6
2 8 10 5 -2 5
10
Sample Output 2:
0
2
Explanation for Input 2:
Since there doesn't exist any pair with sum equal to 12 for the first query, we print 0.
For the second query, we have 2 pairs in total that sum up to 10. They are, (2, 8) and (5, 5).

Solution :
n = int(input())
a = [int(x) for x in input().split()]
sum = int(input())
for i in range (len(a)):
    for j in range (i+1,len(a)):
        if a[i]+a[j]==sum:
            if(a[i]<a[j]):
                print(a[i]," ",a[j])
            else:
                print(a[j]," ",a[i])


#Triplet Sum
"""
You have been given a random integer array/list(ARR) and a number X.
Find and return the triplet(s) in the array/list which sum to X.

Note :
Given array/list can contain duplicate elements.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the first array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Third line contains an integer 'X'.

Output format :
For each test case, print the total number of triplets present in the array/list.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
1 2 3 4 5 6 7
12
Sample Output 1:
5
Sample Input 2:
2
7
1 2 3 4 5 6 7
19
9
2 -5 8 -6 0 5 10 11 -3
10
Sample Output 2:
0
5
Explanation for Input 2:
Since there doesn't exist any triplet with sum equal to 19 for the first query, we print 0.
For the second query, we have 5 triplets in total that sum up to 10.
They are, (2, 8, 0), (2, 11, -3), (-5, 5, 10), (8, 5, -3) and (-6, 5, 11)

Solution :
n = int(input())
a = [int(x) for x in input().split()]
sum = int(input())
for i in range(len(a)):
    for j in range(i + 1, len(a)):
        for k in range(j + 1, len(a)):

            if a[i] + a[j] + a[k] == sum:

                if (a[i] <= a[j] <= a[k]):
                    print(a[i], " ", a[j], " ", a[k])

                elif (a[k] <= a[j] <= a[i]):
                    print(a[k], " ", a[j], " ", a[i])

                elif (a[k] <= a[i] <= a[j]):
                    print(a[k], " ", a[i], " ", a[j])

                elif (a[i] <= a[k] <= a[j]):
                    print(a[i], " ", a[k], " ", a[j])

                elif (a[j] <= a[i] <= a[k]):
                    print(a[j], " ", a[i], " ", a[k])

                elif (a[j] <= a[k] <= a[i]):
                    print(a[j], " ", a[k], " ", a[i])


#Sort 0 1
"""
You have been given an integer array/list(ARR) of size N that contains only integers, 0 and 1.
Write a function to sort this array/list.
Think of a solution which scans the array/list only once and don't require use of an extra array/list.

Note:
You need to change in the given array/list itself. Hence, no need to return or print anything.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers(all 0s and 1s) representing the elements in the array/list.

Output format :
For each test case, print the sorted array/list elements in a row separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
0 1 1 0 1 0 1
Sample Output 1:
0 0 0 1 1 1 1
Sample Input 2:
2
8
1 0 1 1 0 1 0 1
5
0 1 0 1 0
Sample Output 2:
0 0 0 1 1 1 1 1
0 0 0 1 1

Solution :
def count(li):
    total_one=0
    total_zero = 0
    for ele in li:
        if ele == 1:
            total_one+=1
        else:
            total_zero+=1
    return [total_one, total_zero]
n=int(input())
li=[int(x) for x in input().split()]
total_array=count(li)
finalArray = []
for i in range(total_array[1]):
    finalArray.append(0)
for i in range (total_array[0]):
    finalArray.append(1)
for x in finalArray:
    print(x,end=" ")




#Binary Search
"""
You have been given a sorted(in ascending order) integer array/list(ARR) of size N and an element X.
Write a function to search this element in the given input array/list using 'Binary Search'.
Return the index of the element in the input array/list.
In case the element is not present in the array/list, then return -1.

Input format :
The first line contains an Integer 'N' which denotes the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Third line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow..

All the 't' lines henceforth, will take the value of X to be searched for in the array/list

Output Format :
For each test case, print the index at which X is present, -1 otherwise.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
7
1 3 7 9 11 12 45
1
3
Sample Output 1:
1

Sample Input 2:
7
1 2 3 4 5 6 7
2
9
7
Sample Output 2:
-1
6

Solution :

def binarysearch(arr,element):
    start=0
    end=len(arr)-1

    while (start<=end):
        mid=(start+end)//2

        if (arr[mid]==element):
            return mid

        elif (arr[mid]<element):
            start=mid+1

        else:
            end=mid-1

    return -1

n=int(input())
arr = [int(x) for x in input().split()]
element=int(input())
index=binarysearch(arr,element)
print(index)


#Bubble Sort
"""
Provided with a random integer array/list(ARR) of size N,
you have been required to sort this array using 'Bubble Sort'.

Note:
Change in the input array/list itself. You don't need to return or print the elements.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Output format :
For each test case, print the elements of the array/list in sorted order separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
2 13 4 1 3 6 28
Sample Output 1:
1 2 3 4 6 13 28

Sample Input 2:
2
5
9 3 6 2 0
4
4 3 2 1
Sample Output 2:
0 2 3 6 9
1 2 3 4

Solution :

def bubbleSort(arr):
    length = len(arr)

    for i in range(length - 1):

        for j in range(length - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]

n = int(input())
arr = [int(x) for x in input().split()]
bubbleSort(arr)
for x in arr:
    print(x, end=" ")


#Insertion Sort
"""
Provided with a random integer array/list(ARR) of size N,
you have been required to sort this array using 'Insertion Sort'.

Note:
Change in the input array/list itself. You don't need to return or print the elements.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the elements of the array/list in sorted order separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
2 13 4 1 3 6 28
Sample Output 1:
1 2 3 4 6 13 28

Sample Input 2:
2
5
9 3 6 2 0
4
4 3 2 1
Sample Output 2:
0 2 3 6 9
1 2 3 4

Solution :

def insertionSort(arr):
    length=len(arr)

    for i in range (1,length):
        j=i-1
        temp=arr[i]

        while (j>=0 and arr[j]>temp):
            arr[j+1]=arr[j]
            j=j-1

        arr[j+1]=temp

n=int(input())
arr=[int(x) for x in input().split()]
insertionSort(arr)
for x in arr:
    print(x,end=" ")


#Merge Two Sorted Arrays
"""
You have been given two sorted arrays/lists(ARR1 and ARR2) of size N and M respectively,
merge them into a third array/list such that the third array is also sorted.

Input Format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the first array/list.

Second line contains 'N' single space separated integers representing the elements of the first array/list.

Third line contains an integer 'M' representing the size of the second array/list.

Fourth line contains 'M' single space separated integers representing the elements of the second array/list.

Output Format :
For each test case, print the sorted array/list(of size N + M) in a single row, separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1 :
1
5
1 3 4 7 11
4
2 4 6 13
Sample Output 1 :
1 2 3 4 4 6 7 11 13

Sample Input 2 :
2
3
10 100 500
7
4 7 9 25 30 300 450
4
7 45 89 90
0
Sample Output 2 :
4 7 9 10 25 30 100 300 450 500
7 45 89 90

Solution :

def mergedArr(arr1, arr2):
    i = 0
    j = 0
    len1 = len(arr1)
    len2 = len(arr2)
    arr = []

    while ((i < len1) and (j < len2)):

        if (arr1[i] < arr2[j]):
            arr.append(arr1[i])
            i = i + 1

        else:
            arr.append(arr2[j])
            j = j + 1

    while (i < len1):
        arr.append(arr1[i])
        i = i + 1

    while (j < len2):
        arr.append(arr2[j])
        j = j + 1

    return arr

n = int(input())
arr1 = [int(x) for x in input().split()]
m = int(input())
arr2 = [int(x) for x in input().split()]
arr = mergedArr(arr1, arr2)
for x in (arr):
    print(x, end=" ")


#Push Zeros to end
"""
You have been given a random integer array/list(ARR) of size N.
You have been required to push all the zeros that are present in the array/list to the end of it.
Also, make sure to maintain the relative order of the non-zero elements.

Note:
Change in the input array/list itself. You don't need to return or print the elements.
You need to do this in one scan of array only. Don't use extra space.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the elements of the array/list in the desired order separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
2 0 0 1 3 0 0
Sample Output 1:
2 1 3 0 0 0 0
Explanation for the Sample Input 1 :
All the zeros have been pushed towards the end of the array/list.
Another important fact is that the order of the non-zero elements have been maintained as they appear in the input array/list.
Sample Input 2:
2
5
0 3 0 2 0
4
9 0 0 8 2
Sample Output 2:
3 2 0 0 0
9 8 2 0 0

Solution :

def pushZerosToEnd(arr, n):
    count = 0

    for i in range(n):

        if arr[i] != 0:
            arr[count] = arr[i]
            count += 1

    while count < n:
        arr[count] = 0
        count += 1

n = int(input())
arr = [int(x) for x in input().split()]
pushZerosToEnd(arr, n)
for x in (arr):
    print(x, end=" ")


#Rotate array
"""
You have been given a random integer array/list(ARR) of size N.
Write a function that rotates the given array/list by D elements(towards the left).

Note:
Change in the input array/list itself. You don't need to return or print the elements.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Third line contains the value of 'D' by which the array/list needs to be rotated.

Output Format :
For each test case, print the rotated array/list in a row separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
1 2 3 4 5 6 7
2
Sample Output 1:
3 4 5 6 7 1 2

Sample Input 2:
2
7
1 2 3 4 5 6 7
0
4
1 2 3 4
2
Sample Output 2:
1 2 3 4 5 6 7
3 4 1 2

Solution :

def leftRotate(arr, d, n):

    for i in range(d):
        leftRotatebyOne(arr, n)

def leftRotatebyOne(arr, n):
    temp = arr[0]

    for i in range(n - 1):
        arr[i] = arr[i + 1]

    arr[n - 1] = temp

def printArray(arr, size):

    for i in range(size):
        print("%d" % arr[i], end=" ")

n = int(input())
arr = [int(x) for x in input().split()]
d = int(input())
leftRotate(arr, d, n)
printArray(arr, n)


#Second Largest in array
"""
You have been given a random integer array/list(ARR) of size N.
You are required to find and return the second largest element present in the array/list.
If N <= 1 or all the elements are same in the array/list then return -2147483648 or -2 ^ 31(It is the smallest value for the range of Integer)

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the second largest in the array/list if exists, -2147483648 otherwise.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
2 13 4 1 3 6 28
Sample Output 1:
13

Sample Input 2:
1
5
9 3 6 2 9
Sample Output 2:
6

Sample Input 3:
2
2
6 6
4
90 8 90 5
Sample Output 3:
-2147483648
8

Solution :

def second_largest(lst):
    L = float('-inf')
    S = float('-inf')

    for i in range(len(lst)):

        if float(lst[i]) > L:
            S = L
            L = float(lst[i])

        elif float(lst[i]) < L:

            if float(lst[i]) > S:
                S = float(lst[i])

    print(int(S))

n = int(input())
lst = list(int(x) for x in input().split())
second_largest(lst)


#Check Array Rotation
"""
You have been given an integer array/list(ARR) of size N.
It has been sorted(in increasing order) and then rotated by some number 'K' in the clockwise direction.
Your task is to write a function that returns the value of 'K',
that means, the index from which the array/list has been rotated.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers representing the elements in the array/list.

Output Format :
For each test case, print the value of 'K' or the index from which which the array/list has been rotated.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
6
5 6 1 2 3 4
Sample Output 1:
2

Sample Input 2:
2
5
3 6 8 9 10
4
10 20 30 1
Sample Output 2:
0
3

Solution :

def countRotations(arr, low, high):

    if (high < low):
        return 0

    if (high == low):
        return low

    mid = low + (high - low) / 2;
    mid = int(mid)

    if (mid < high and arr[mid + 1] < arr[mid]):
        return (mid + 1)

    if (mid > low and arr[mid] < arr[mid - 1]):
        return mid

    if (arr[high] > arr[mid]):
        return countRotations(arr, low, mid - 1);

    return countRotations(arr, mid + 1, high)

m = int(input())
arr = [int(x) for x in input().split()]
n = len(arr)
print(countRotations(arr, 0, n - 1))


#Sort 0 1 2
"""
You are given an integer array/list(ARR) of size N. It contains only 0s, 1s and 2s.
Write a solution to sort this array/list in a 'single scan'.
'Single Scan' refers to iterating over the array/list just once or to put it in other words,
you will be visiting each element in the array/list just once.

Note:
You need to change in the given array/list itself. Hence, no need to return or print anything.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the array/list.

Second line contains 'N' single space separated integers(all 0s, 1s and 2s) representing the elements in the array/list.

Output Format :
For each test case, print the sorted array/list elements in a row separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
7
0 1 2 0 2 0 1
Sample Output 1:
0 0 0 1 1 2 2

Sample Input 2:
2
5
2 2 0 1 1
7
0 1 2 0 1 2 0
Sample Output 2:
0 1 1 2 2
0 0 0 1 1 2 2

Solution :

def count(li):
    total_one=0
    total_zero = 0
    total_two=0

    for ele in li:

        if ele == 1:
            total_one+=1

        elif ele ==0:
            total_zero+=1

        elif ele==2:
            total_two+=1

    return [total_one, total_zero,total_two]

n=int(input())
li=[int(x) for x in input().split()]
total_array=count(li)
finalArray = []

for i in range(total_array[1]):
    finalArray.append(0)

for i in range (total_array[0]):
    finalArray.append(1)

for i in range(total_array[2]):
    finalArray.append(2)

for x in finalArray:
    print(x,end=" ")


#Sum of Two Arrays
"""
Two random integer arrays/lists have been given as ARR1 and ARR2 of size N and M respectively.
Both the arrays/lists contain numbers from 0 to 9(i.e. single digit integer is present at every index).
The idea here is to represent each array/list as an integer in itself of digits N and M.
You need to find the sum of both the input arrays/list treating them as two integers and put the result in another array/list i.e. output array/list will also contain only single digit at every index.

Note:
The sizes N and M can be different. 
Output array/list(of all 0s) has been provided as a function argument. 
Its size will always be one more than the size of the bigger array/list. Place 0 at the 0th index if there is no carry. 
No need to print the elements of the output array/list.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains an integer 'N' representing the size of the first array/list.

Second line contains 'N' single space separated integers representing the elements of the first array/list.

Third line contains an integer 'M' representing the size of the second array/list.

Fourth line contains 'M' single space separated integers representing the elements of the second array/list.

Output Format :
For each test case, print the required sum of the arrays/list in a row, separated by a single space.
Output for every test case will be printed in a separate line.
"""
Sample Input 1:
1
3
6 2 4
3
7 5 6
Sample Output 1:
1 3 8 0

Sample Input 2:
2
3
8 5 2
2
1 3
4
9 7 6 1
3
4 5 9
Sample Output 2:
0 8 6 5
1 0 2 2 0

Solution :

def convert2number(arr):
    number=0

    for item in arr:
        number=(number*10)+item

    return number

def convert2array(number,length):
    arr=list(str(number))

    if len(arr) < length + 1:

        for x in range (len(arr),length+1):
            arr.insert(0,"0")

    return arr

n=int(input())
arr1=[int(x) for x in input().split()]
m=int(input())
arr2=[int(x) for x in input().split()]
number1=convert2number(arr1)
number2=convert2number(arr2)
biggerArrSize = 0

if len(arr1) >= len(arr2):
    biggerArrSize = len(arr1)

else:
    biggerArrSize = len(arr2)

final_arr=convert2array(number1+number2,biggerArrSize)
for x in final_arr:
    print(x,end=" ")



#Check Palindrome
"""
Given a String s, check it its palindrome. Return true if string is palindrome, else return false.
Palindrome strings are those, where string s and its reverse is exactly same.

Input Format :
 String S

Output Format :
"true" if S is palindrome, else "false"
"""
Sample Input 1 :
abcdcba
Sample Output 1 :
true

Sample Input 2 :
abcd
Sample Output 2 :
false

Solution :
def reverse(s):
    return s[::-1]

def isPalindrome(s):
    rev = reverse(s)
    if (s == rev):
        return True
    return False

s = input()
ans = isPalindrome(s)
if ans == 1:
    print("true")
else:
    print("false")


#Check Permutation
"""
Given two strings, S and T, check if they are permutations of each other. Return true or false.
Permutation means - length of both the strings should same and should contain same set of characters.
Order of characters doesn't matter.

Note : Input strings contain only lowercase english alphabets.

Input format :
Line 1 : String 1
Line 2 : String 2

Output format :
'true' or 'false'
"""
Sample Input 1 :
abcde
baedc
Sample Output 1 :
true

Sample Input 2 :
abc
cbd
Sample Output 2 :
false

Solution :

NO_OF_CHARS = 256

def Permutation(str1, str2):
    count1 = [0] * NO_OF_CHARS
    count2 = [0] * NO_OF_CHARS

    for i in str1:
        count1[ord(i)] += 1

    for i in str2:
        count2[ord(i)] += 1

    if len(str1) != len(str2):
        return 0

    for i in range(NO_OF_CHARS):
        if count1[i] != count2[i]:
            return 0

    return 1

str1 = input()
str2 = input()
if Permutation(str1, str2):
    print("true")
else:
    print("false")


#Remove Consecutive Duplicates
"""
Given a string, S, remove all the consecutive duplicates that are present in the given string.
That means, if 'aaa' is present in the string then it should become 'a' in the output string.

Input format :
String S

Output format :
Modified string
"""
Sample Input 1:
aabccbaa
Sample Output 1:
abcba

Sample Input 2:
xxyyzxx
Sample Output 2:
xyzx

Solution :

def removeDuplicates(S):
    n = len(S)
    if (n < 2):
        return

    j = 0
    for i in range(n):

        if (S[j] != S[i]):
            j += 1
            S[j] = S[i]
    j += 1
    S = S[:j]
    return S

if __name__ == '__main__':
    S1 = input()
    S1 = list(S1.rstrip())
    S1 = removeDuplicates(S1)
    print(*S1, sep="")


#Reverse Each Word
"""
Given a string S, reverse each word of a string individually.
For eg. if a string is "abc def", reversed string should be "cba fed".

Input Format :
String S

Output Format :
Modified string
"""
Sample Input 1:
Welcome to Coding Ninjas
Sample Output 1:
emocleW ot gnidoC sajniN

Sample Input 2:
Give proper names to variables and functions
Sample Output 2:
eviG reporp seman ot selbairav dna snoitcnuf

Solution :
def reverseWordSentence(Sentence):
    return ' '.join(word[::-1] for word in Sentence.split(" "))

Sentence = input()
print(reverseWordSentence(Sentence))


#Remove character
"""
Given a string and a character x.
Write a function to remove all occurrences of x character from the given string.
Leave the string as it is, if the given character is not present in the string.

Input Format :
Line 1 : String S
Line 2 : Character c

Output Format :
Modified string
"""
Sample Input 1:
welcome to coding ninjas
o
Sample Output 1:
welcme t cding ninjas

Sample Input 2:
Think of edge cases before submitting solutions
x
Sample Output 2:
Think of edge cases before submitting solutions

Solution :

test_string = input()
x = input()

for i in x:
    test_string = test_string.replace(i, '')

print(str(test_string))


#Highest Occurring Character
"""
Given a string, S, find and return the highest occurring character present in the given string.
If there are 2 characters in the input string with same frequency, return the character which comes first.

Note : Assume all the characters in the given string are lowercase.

Input format :
String S

Output format :
Highest occurring character
"""
Sample Input 1:
abdefgbabfba
Sample Output 1:
b

Sample Input 2:
xy
Sample Output 2:
x

Solution :

ASCII_SIZE = 256

def getMaxOccuringChar(str):
    count = [0] * ASCII_SIZE

    max = -1
    c = ''
    for i in str:
        count[ord(i)] += 1;

    for i in str:
        if max < count[ord(i)]:
            max = count[ord(i)]
            c = i

    return c

str = input()
print(getMaxOccuringChar(str))


#Compress the String
"""
Write a program to do basic string compression.
For a character which is consecutively repeated more than once,
replace consecutive duplicate occurrences with the count of repetitions.
For e.g. if a String has 'x' repeated 5 times, replace this "xxxxx" with "x5".

Note : Consecutive count of every character in input string is less than equal to 9.

Input Format :
String S

Output Format :
Compressed string 
"""
Sample Input 1 :
aaabbccdsa
Sample Output 1 :
a3b2c2dsa

Sample Input 2 :
aaabbcddeeeee
Sample Output 2 :
a3b2cd2e5

Solution :

str1 = input()
str2 = ''
m = 0
i = 0

while i < len(str1):
    count = 0
    temp = str1[i]
    for j in range(i, len(str1)):
        if str1[j] == temp:
            count += 1
        else:
            break
    if count > 1:
        str2 += str1[i] + str(count)

    else:
        str2 += str1[i]
    i = i + count - 1
    i += 1
print(str2)




#Row Wise Sum
"""
For a given two-dimensional integer array/list of size (N x M),
find and print the sum of each of the row elements in a single line, separated by a single space.

Input Format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains two integer values, 'N' and 'M', separated by a single space. They represent the 'rows' and 'columns' respectively, for the two-dimensional array/list.

Second line onwards, the next 'N' lines or rows represent the ith row values.

Each of the ith row constitutes 'M' column values separated by a single space.

Output Format :
For each test case, print the sum of every ith row elements in a single line separated by a single space.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1:
1
4 2
1 2
3 4
5 6
7 8
Sample Output 1:
3 7 11 15

Sample Input 2:
2
2 5
4 5 3 2 6
7 5 3 8 9
4 4
1 2 3 4
9 8 7 6
3 4 5 6
-1 1 -10 5
Sample Output 2:
20 32
10 30 18 -5

Solution :

str = input().split()
n, m = int(str[0]), int(str[1])
b = input().split()
arr = [[int(b[m * i + j]) for j in range(m)] for i in range(n)]

newArr = []
for row in arr:
    sum = 0
    for ele in row:
        sum += ele
    newArr.append(sum)

for ele in newArr:
    print(ele, end=" ")


#Largest Row or Column
"""
For a given two-dimensional integer array/list of size (N x M), 
you need to find out which row or column has the largest sum(sum of all the elements in a row/column) amongst all the rows and columns.

Note :
If there are more than one rows/columns with maximum sum, consider the row/column that comes first.
And if ith row and jth column has the same largest sum, consider the ith row as answer

Input Format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run. 
Then the test cases follow.

First line of each test case or query contains two integer values, 'N' and 'M', separated by a single space. They represent the 'rows' and 'columns' respectively, for the two-dimensional array/list.

Second line onwards, the next 'N' lines or rows represent the ith row values.

Each of the ith row constitutes 'M' column values separated by a single space.

Output Format :
For each test case, If row sum is maximum, then print: "row" <row_index> <row_sum>
OR
If column sum is maximum, then print: "column" <col_index> <col_sum>
It will be printed in a single line separated by a single space between each piece of information.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1 :
1
2 2
1 1
1 1
Sample Output 1 :
row 0 2

Sample Input 2 :
2
3 3
3 6 9
1 4 7
2 8 9
4 2
1 2
90 100
3 40
-10 200
Sample Output 2 :
column 2 25
column 1 342

Solution :

def largestRowCol(arr):
    rows = len(arr)
    cols = len(arr[0])

    sumRow = [0] * rows
    sumCol = [0] * cols

    for i in range(rows):
        for j in range(cols):
            sumRow[i]+= arr[i][j]
            sumCol[j]+= arr[i][j]

    l = ['row', 0, sumRow[0]]

    for i in range(rows):
        if sumRow[i] > l[2]:
            l[2] = sumRow[i]
            l[1] = i

    for j in range(cols):
        if sumCol[j] > l[2]:
            l[2] = sumCol[j]
            l[1] = j
            l[0] = 'column'

    return l

m, n = [int(x) for x in input().strip().split()]
l = [int(i) for i in input().split()]
arr = [ [ l[(j*n)+i] for i in range(n)] for j in range(m)]
l = largestRowCol(arr)
print(*l)


#Wave Print
"""
For a given two-dimensional integer array/list of size (N x M),
print the array/list in a sine wave order, i.e, print the first column top to bottom, next column bottom to top and so on.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains two integer values, 'N' and 'M', separated by a single space. They represent the 'rows' and 'columns' respectively, for the two-dimensional array/list.

Second line onwards, the next 'N' lines or rows represent the ith row values.

Each of the ith row constitutes 'M' column values separated by a single space.

Output format :
For each test case, print the elements of the two-dimensional array/list in the sine wave order in a single line, separated by a single space.
Output for every test case will be printed in a seperate line.
"""
Sample Input 1:
1
3 4
1  2  3  4
5  6  7  8
9 10 11 12
Sample Output 1:
1 5 9 10 6 2 3 7 11 12 8 4

Sample Input 2:
2
5 3
1 2 3
4 5 6
7 8 9
10 11 12
13 14 15
3 3
10 20 30
40 50 60
70 80 90
Sample Output 2:
1 4 7 10 13 14 11 8 5 2 3 6 9 12 15
10 40 70 80 50 20 30 60 90

Solution :

def wave_Print(twoDArr,row,col):
    top=0
    bottom=row-1
    left=0
    right=col-1
    direction=0

    while (left<=right):

        if (direction==0):
            for i in range(top,bottom+1):
                print(twoDArr[i][left],end=" ")
            left+=1
            direction=1

        elif (direction==1):
            for i in range(bottom,top-1,-1):
                print(twoDArr[i][left],end=" ")
            left+=1
            direction=0

l=[int(i) for i in input().strip().split(" ")]
row,col = l[0],l[1]
arr=[[l[(j*col)+i+2] for i in range(col)] for j in range(row)]
wave_Print(arr,row,col)


#Spiral Print
"""
For a given two-dimensional integer array/list of size (N x M), print it in a spiral form.
That is, you need to print in the order followed for every iteration:
a. First row(left to right)
b. Last column(top to bottom)
c. Last row(right to left)
d. First column(bottom to top)
Mind that every element will be printed only once.

Input format :
The first line contains an Integer 't' which denotes the number of test cases or queries to be run.
Then the test cases follow.

First line of each test case or query contains two integer values, 'N' and 'M', separated by a single space. They represent the 'rows' and 'columns' respectively, for the two-dimensional array/list.

Second line onwards, the next 'N' lines or rows represent the ith row values.

Each of the ith row constitutes 'M' column values separated by a single space.

Output format :
For each test case, print the elements of the two-dimensional array/list in the spiral form in a single line, separated by a single space.
Output for every test case will be printed in a seperate line. 
"""
Sample Input 1:
1
4 4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
Sample Output 1:
1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10

Sample Input 2:
2
3 3
1 2 3
4 5 6
7 8 9
3 1
10
20
30
Sample Output 2:
1 2 3 6 9 8 7 4 5
10 20 30

Solution :

def spiralPrint(twoDArr,row,col):
    top=0
    bottom=row-1
    left=0
    right=col-1
    direction=0

    while (top<=bottom) and (left<=right):

        if (direction==0):
            for i in range(left,right+1):
                print(twoDArr[top][i],end=" ")
            top+=1
            direction=1

        elif (direction==1):
            for i in range(top,bottom+1):
                print(twoDArr[i][right],end=" ")
            right-=1
            direction=2

        elif (direction==2):
            for i in range(right,left-1,-1):
                print(twoDArr[bottom][i],end=" ")
            bottom-=1
            direction=3

        elif (direction==3):
            for i in range(bottom,top-1,-1):
                print(twoDArr[i][left],end=" ")
            left+=1
            direction=0

l=[int(i) for i in input().strip().split(" ")]
row,col = l[0],l[1]
arr=[[l[(j*col)+i+2] for i in range(col)] for j in range(row)]
spiralPrint(arr,row,col)

